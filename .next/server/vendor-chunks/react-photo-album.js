"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-photo-album";
exports.ids = ["vendor-chunks/react-photo-album"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-photo-album/dist/index.mjs":
/*!*******************************************************!*\
  !*** ./node_modules/react-photo-album/dist/index.mjs ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PhotoAlbum: () => (/* binding */ PhotoAlbum),\n/* harmony export */   \"default\": () => (/* binding */ PhotoAlbum),\n/* harmony export */   unstable_computeColumnsLayout: () => (/* binding */ computeColumnsLayout),\n/* harmony export */   unstable_computeMasonryLayout: () => (/* binding */ computeMasonryLayout),\n/* harmony export */   unstable_computeRowsLayout: () => (/* binding */ computeRowsLayout)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* __next_internal_client_entry_do_not_use__ PhotoAlbum,default,unstable_computeColumnsLayout,unstable_computeMasonryLayout,unstable_computeRowsLayout auto */ \nfunction ratio({ width, height }) {\n    return width / height;\n}\nfunction round(value, decimals = 0) {\n    const factor = 10 ** decimals;\n    return Math.round((value + Number.EPSILON) * factor) / factor;\n}\nfunction rankingFunctionComparator(rank) {\n    return (a, b)=>rank(b) - rank(a);\n}\nclass MinHeap {\n    constructor(comparator){\n        this.comparator = comparator;\n        this.heap = [];\n        this.n = 0;\n    }\n    greater(i, j) {\n        return this.comparator(this.heap[i], this.heap[j]) < 0;\n    }\n    swap(i, j) {\n        const temp = this.heap[i];\n        this.heap[i] = this.heap[j];\n        this.heap[j] = temp;\n    }\n    swim(i) {\n        let k = i;\n        let k2 = Math.floor(k / 2);\n        while(k > 1 && this.greater(k2, k)){\n            this.swap(k2, k);\n            k = k2;\n            k2 = Math.floor(k / 2);\n        }\n    }\n    sink(i) {\n        let k = i;\n        let k2 = k * 2;\n        while(k2 <= this.n){\n            if (k2 < this.n && this.greater(k2, k2 + 1)) k2 += 1;\n            if (!this.greater(k, k2)) break;\n            this.swap(k, k2);\n            k = k2;\n            k2 = k * 2;\n        }\n    }\n    push(element) {\n        this.n += 1;\n        this.heap[this.n] = element;\n        this.swim(this.n);\n    }\n    pop() {\n        if (this.n === 0) return void 0;\n        this.swap(1, this.n);\n        this.n -= 1;\n        const max = this.heap.pop();\n        this.sink(1);\n        return max;\n    }\n    size() {\n        return this.n;\n    }\n}\nfunction buildPrecedentsMap(graph, startNode, endNode) {\n    const precedentsMap = /* @__PURE__ */ new Map();\n    const visited = /* @__PURE__ */ new Set();\n    const storedShortestPaths = /* @__PURE__ */ new Map();\n    storedShortestPaths.set(startNode, 0);\n    const queue = new MinHeap(rankingFunctionComparator((el)=>el.weight));\n    queue.push({\n        id: startNode,\n        weight: 0\n    });\n    while(queue.size() > 0){\n        const { id, weight } = queue.pop();\n        if (!visited.has(id)) {\n            const neighboringNodes = graph(id);\n            visited.add(id);\n            neighboringNodes.forEach((neighborWeight, neighbor)=>{\n                const newWeight = weight + neighborWeight;\n                const currentId = precedentsMap.get(neighbor);\n                const currentWeight = storedShortestPaths.get(neighbor);\n                if (currentWeight === void 0 || currentWeight > newWeight && (currentWeight / newWeight > 1.005 || currentId !== void 0 && currentId < id)) {\n                    storedShortestPaths.set(neighbor, newWeight);\n                    queue.push({\n                        id: neighbor,\n                        weight: newWeight\n                    });\n                    precedentsMap.set(neighbor, id);\n                }\n            });\n        }\n    }\n    return storedShortestPaths.has(endNode) ? precedentsMap : void 0;\n}\nfunction getPathFromPrecedentsMap(precedentsMap, endNode) {\n    const nodes = [];\n    for(let node = endNode; node !== void 0; node = precedentsMap.get(node)){\n        nodes.push(node);\n    }\n    return nodes.reverse();\n}\nfunction findShortestPath(graph, startNode, endNode) {\n    const precedentsMap = buildPrecedentsMap(graph, startNode, endNode);\n    return precedentsMap ? getPathFromPrecedentsMap(precedentsMap, endNode) : void 0;\n}\nfunction findIdealNodeSearch({ photos, targetRowHeight, containerWidth }) {\n    const minRatio = photos.reduce((acc, photo)=>Math.min(ratio(photo), acc), Number.MAX_VALUE);\n    return round(containerWidth / targetRowHeight / minRatio) + 2;\n}\nfunction getCommonHeight(row, containerWidth, spacing, padding) {\n    const rowWidth = containerWidth - (row.length - 1) * spacing - 2 * padding * row.length;\n    const totalAspectRatio = row.reduce((acc, photo)=>acc + ratio(photo), 0);\n    return rowWidth / totalAspectRatio;\n}\nfunction cost(photos, i, j, width, targetRowHeight, spacing, padding) {\n    const row = photos.slice(i, j);\n    const commonHeight = getCommonHeight(row, width, spacing, padding);\n    return commonHeight > 0 ? (commonHeight - targetRowHeight) ** 2 * row.length : void 0;\n}\nfunction makeGetRowNeighbors({ photos, layoutOptions, targetRowHeight, limitNodeSearch, rowConstraints }) {\n    return (node)=>{\n        var _a, _b;\n        const { containerWidth, spacing, padding } = layoutOptions;\n        const results = /* @__PURE__ */ new Map();\n        results.set(node, 0);\n        const startOffset = (_a = rowConstraints == null ? void 0 : rowConstraints.minPhotos) != null ? _a : 1;\n        const endOffset = Math.min(limitNodeSearch, (_b = rowConstraints == null ? void 0 : rowConstraints.maxPhotos) != null ? _b : Infinity);\n        for(let i = node + startOffset; i < photos.length + 1; i += 1){\n            if (i - node > endOffset) break;\n            const currentCost = cost(photos, node, i, containerWidth, targetRowHeight, spacing, padding);\n            if (currentCost === void 0) break;\n            results.set(i, currentCost);\n        }\n        return results;\n    };\n}\nfunction computeRowsLayout({ photos, layoutOptions }) {\n    const { spacing, padding, containerWidth, targetRowHeight, rowConstraints } = layoutOptions;\n    const limitNodeSearch = findIdealNodeSearch({\n        photos,\n        containerWidth,\n        targetRowHeight\n    });\n    const getNeighbors = makeGetRowNeighbors({\n        photos,\n        layoutOptions,\n        targetRowHeight,\n        limitNodeSearch,\n        rowConstraints\n    });\n    const path = findShortestPath(getNeighbors, 0, photos.length);\n    if (path === void 0) return void 0;\n    const layout = [];\n    for(let i = 1; i < path.length; i += 1){\n        const row = photos.map((photo, index)=>({\n                photo,\n                index\n            })).slice(path[i - 1], path[i]);\n        const height = getCommonHeight(row.map(({ photo })=>photo), containerWidth, spacing, padding);\n        layout.push(row.map(({ photo, index }, photoIndex)=>({\n                photo,\n                layout: {\n                    height,\n                    width: height * ratio(photo),\n                    index,\n                    photoIndex,\n                    photosCount: row.length\n                }\n            })));\n    }\n    return layout;\n}\nfunction clsx(...classes) {\n    return [\n        ...classes\n    ].filter((cls)=>Boolean(cls)).join(\" \");\n}\nfunction calcWidth(base, photoLayout, layoutOptions) {\n    const { width, photosCount } = photoLayout;\n    const { layout, spacing, padding, containerWidth } = layoutOptions;\n    const count = layout === \"rows\" ? photosCount : layoutOptions.columns;\n    const gaps = spacing * (count - 1) + 2 * padding * count;\n    return `calc((${base} - ${gaps}px) / ${round((containerWidth - gaps) / width, 5)})`;\n}\nfunction cssPhotoWidth(layout, layoutOptions) {\n    return layoutOptions.layout !== \"rows\" ? `calc(100% - ${2 * layoutOptions.padding}px)` : calcWidth(\"100%\", layout, layoutOptions);\n}\nfunction calculateSizesValue(size, layout, layoutOptions) {\n    var _a, _b;\n    return calcWidth((_b = (_a = size.match(/^\\s*calc\\((.*)\\)\\s*$/)) == null ? void 0 : _a[1]) != null ? _b : size, layout, layoutOptions);\n}\nfunction srcSetAndSizes(photo, layout, layoutOptions) {\n    var _a;\n    let srcSet;\n    let sizes;\n    const images = photo.srcSet || photo.images;\n    if (images && images.length > 0) {\n        srcSet = images.concat(!images.find(({ width })=>width === photo.width) ? [\n            {\n                src: photo.src,\n                width: photo.width,\n                height: photo.height\n            }\n        ] : []).sort((first, second)=>first.width - second.width).map((image)=>`${image.src} ${image.width}w`).join(\", \");\n    }\n    if ((_a = layoutOptions.sizes) == null ? void 0 : _a.size) {\n        sizes = (layoutOptions.sizes.sizes || []).map(({ viewport, size })=>`${viewport} ${calculateSizesValue(size, layout, layoutOptions)}`).concat(calculateSizesValue(layoutOptions.sizes.size, layout, layoutOptions)).join(\", \");\n    } else {\n        sizes = `${Math.ceil(layout.width / layoutOptions.containerWidth * 100)}vw`;\n    }\n    return {\n        srcSet,\n        sizes\n    };\n}\nfunction PhotoRenderer(props) {\n    var _a, _b;\n    const { photo, layout, layoutOptions, imageProps: { style, className, ...restImageProps } = {}, renderPhoto } = props;\n    const { onClick } = layoutOptions;\n    const imageStyle = {\n        display: \"block\",\n        boxSizing: \"content-box\",\n        width: cssPhotoWidth(layout, layoutOptions),\n        height: \"auto\",\n        aspectRatio: `${photo.width} / ${photo.height}`,\n        ...layoutOptions.padding ? {\n            padding: `${layoutOptions.padding}px`\n        } : null,\n        ...(layoutOptions.layout === \"columns\" || layoutOptions.layout === \"masonry\") && layout.photoIndex < layout.photosCount - 1 ? {\n            marginBottom: `${layoutOptions.spacing}px`\n        } : null,\n        ...onClick ? {\n            cursor: \"pointer\"\n        } : null,\n        ...style\n    };\n    const handleClick = onClick ? (event)=>{\n        onClick({\n            event,\n            photo,\n            index: layout.index\n        });\n    } : void 0;\n    const imageProps = {\n        src: photo.src,\n        alt: (_a = photo.alt) != null ? _a : \"\",\n        title: photo.title,\n        onClick: handleClick,\n        style: imageStyle,\n        className: clsx(\"react-photo-album--photo\", className),\n        loading: \"lazy\",\n        decoding: \"async\",\n        ...srcSetAndSizes(photo, layout, layoutOptions),\n        ...restImageProps\n    };\n    const renderDefaultPhoto = (options)=>{\n        const { src, alt, srcSet, sizes, style: unwrappedStyle, ...rest } = imageProps;\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"img\", {\n            alt,\n            ...srcSet ? {\n                srcSet,\n                sizes\n            } : null,\n            src,\n            style: (options == null ? void 0 : options.wrapped) ? {\n                display: \"block\",\n                width: \"100%\",\n                height: \"100%\"\n            } : unwrappedStyle,\n            ...rest\n        });\n    };\n    const wrapperStyle = (({ display, boxSizing, width, aspectRatio, padding, marginBottom, cursor })=>({\n            display,\n            boxSizing,\n            width,\n            aspectRatio,\n            padding,\n            marginBottom,\n            cursor\n        }))(imageStyle);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, (_b = renderPhoto == null ? void 0 : renderPhoto({\n        photo,\n        layout,\n        layoutOptions,\n        imageProps,\n        renderDefaultPhoto,\n        wrapperStyle\n    })) != null ? _b : renderDefaultPhoto());\n}\nfunction defaultRenderRowContainer({ rowContainerProps, children }) {\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        ...rowContainerProps\n    }, children);\n}\nfunction RowContainerRenderer(props) {\n    const { layoutOptions, rowIndex, rowsCount, renderRowContainer, rowContainerProps: { style, className, ...restRowContainerProps } = {}, children } = props;\n    const rowContainerProps = {\n        className: clsx(\"react-photo-album--row\", className),\n        style: {\n            display: \"flex\",\n            flexDirection: \"row\",\n            flexWrap: \"nowrap\",\n            alignItems: \"flex-start\",\n            justifyContent: \"space-between\",\n            ...rowIndex < rowsCount - 1 ? {\n                marginBottom: `${layoutOptions.spacing}px`\n            } : null,\n            ...style\n        },\n        ...restRowContainerProps\n    };\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, (renderRowContainer != null ? renderRowContainer : defaultRenderRowContainer)({\n        layoutOptions,\n        rowIndex,\n        rowsCount,\n        rowContainerProps,\n        children\n    }));\n}\nfunction RowsLayout(props) {\n    const { photos, layoutOptions, renderPhoto, renderRowContainer, componentsProps: { imageProps, rowContainerProps } } = props;\n    const rowsLayout = computeRowsLayout({\n        photos,\n        layoutOptions\n    });\n    if (!rowsLayout) return null;\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, rowsLayout.map((row, rowIndex)=>/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(RowContainerRenderer, {\n            key: `row-${rowIndex}`,\n            layoutOptions,\n            rowIndex,\n            rowsCount: rowsLayout.length,\n            renderRowContainer,\n            rowContainerProps\n        }, row.map(({ photo, layout })=>/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(PhotoRenderer, {\n                key: photo.key || photo.src,\n                photo,\n                layout,\n                layoutOptions,\n                renderPhoto,\n                imageProps\n            })))));\n}\nfunction computeShortestPath(graph, pathLength, startNode, endNode) {\n    const matrix = /* @__PURE__ */ new Map();\n    const queue = /* @__PURE__ */ new Set();\n    queue.add(startNode);\n    for(let length = 0; length < pathLength; length += 1){\n        const currentQueue = [\n            ...queue.keys()\n        ];\n        queue.clear();\n        currentQueue.forEach((node)=>{\n            const accumulatedWeight = length > 0 ? matrix.get(node)[length].weight : 0;\n            graph(node).forEach(({ neighbor, weight })=>{\n                let paths = matrix.get(neighbor);\n                if (!paths) {\n                    paths = [];\n                    matrix.set(neighbor, paths);\n                }\n                const newWeight = accumulatedWeight + weight;\n                const nextPath = paths[length + 1];\n                if (!nextPath || nextPath.weight > newWeight && (nextPath.weight / newWeight > 1.0001 || node < nextPath.node)) {\n                    paths[length + 1] = {\n                        node,\n                        weight: newWeight\n                    };\n                }\n                if (length < pathLength - 1 && neighbor !== endNode) {\n                    queue.add(neighbor);\n                }\n            });\n        });\n    }\n    return matrix;\n}\nfunction reconstructShortestPath(matrix, pathLength, endNode) {\n    const path = [\n        endNode\n    ];\n    for(let node = endNode, length = pathLength; length > 0; length -= 1){\n        node = matrix.get(node)[length].node;\n        path.push(node);\n    }\n    return path.reverse();\n}\nfunction findShortestPathLengthN(graph, pathLength, startNode, endNode) {\n    return reconstructShortestPath(computeShortestPath(graph, pathLength, startNode, endNode), pathLength, endNode);\n}\nfunction makeGetColumnNeighbors({ photos, spacing, padding, targetColumnWidth, targetColumnHeight }) {\n    return (node)=>{\n        const results = [];\n        const cutOffHeight = targetColumnHeight * 1.5;\n        let height = targetColumnWidth / ratio(photos[node]) + 2 * padding;\n        for(let i = node + 1; i < photos.length + 1; i += 1){\n            results.push({\n                neighbor: i,\n                weight: (targetColumnHeight - height) ** 2\n            });\n            if (height > cutOffHeight || i === photos.length) {\n                break;\n            }\n            height += targetColumnWidth / ratio(photos[i]) + spacing + 2 * padding;\n        }\n        return results;\n    };\n}\nfunction buildColumnsModel({ path, photos, containerWidth, columnsGaps, columnsRatios, spacing, padding }) {\n    const columnsModel = [];\n    const totalRatio = columnsRatios.reduce((total, columnRatio)=>total + columnRatio, 0);\n    for(let i = 0; i < path.length - 1; i += 1){\n        const column = photos.map((photo, index)=>({\n                photo,\n                index\n            })).slice(path[i], path[i + 1]);\n        const totalAdjustedGaps = columnsRatios.reduce((total, columnRatio, index)=>total + (columnsGaps[i] - columnsGaps[index]) * columnRatio, 0);\n        const columnWidth = (containerWidth - (path.length - 2) * spacing - 2 * (path.length - 1) * padding - totalAdjustedGaps) * columnsRatios[i] / totalRatio;\n        columnsModel.push(column.map(({ photo, index }, photoIndex)=>({\n                photo,\n                layout: {\n                    width: columnWidth,\n                    height: columnWidth / ratio(photo),\n                    index,\n                    photoIndex,\n                    photosCount: column.length\n                }\n            })));\n    }\n    return columnsModel;\n}\nfunction computeColumnsModel({ photos, layoutOptions, targetColumnWidth }) {\n    const { columns, spacing, padding, containerWidth } = layoutOptions;\n    const columnsGaps = [];\n    const columnsRatios = [];\n    if (photos.length <= columns) {\n        const averageRatio = photos.length > 0 ? photos.reduce((acc, photo)=>acc + ratio(photo), 0) / photos.length : 1;\n        for(let i = 0; i < columns; i += 1){\n            columnsGaps[i] = 2 * padding;\n            columnsRatios[i] = i < photos.length ? ratio(photos[i]) : averageRatio;\n        }\n        const columnsModel2 = buildColumnsModel({\n            path: Array.from({\n                length: columns + 1\n            }).map((_, index)=>Math.min(index, photos.length)),\n            photos,\n            columnsRatios,\n            columnsGaps,\n            containerWidth,\n            spacing,\n            padding\n        });\n        return {\n            columnsGaps,\n            columnsRatios,\n            columnsModel: columnsModel2\n        };\n    }\n    const targetColumnHeight = (photos.reduce((acc, photo)=>acc + targetColumnWidth / ratio(photo), 0) + spacing * (photos.length - columns) + 2 * padding * photos.length) / columns;\n    const getNeighbors = makeGetColumnNeighbors({\n        photos,\n        targetColumnWidth,\n        targetColumnHeight,\n        spacing,\n        padding\n    });\n    const path = findShortestPathLengthN(getNeighbors, columns, 0, photos.length);\n    for(let i = 0; i < path.length - 1; i += 1){\n        const column = photos.slice(path[i], path[i + 1]);\n        columnsGaps[i] = spacing * (column.length - 1) + 2 * padding * column.length;\n        columnsRatios[i] = 1 / column.reduce((acc, photo)=>acc + 1 / ratio(photo), 0);\n    }\n    const columnsModel = buildColumnsModel({\n        path,\n        photos,\n        columnsRatios,\n        columnsGaps,\n        containerWidth,\n        spacing,\n        padding\n    });\n    return {\n        columnsGaps,\n        columnsRatios,\n        columnsModel\n    };\n}\nfunction computeLayout(props) {\n    const { photos, layoutOptions } = props;\n    const { columns, spacing, padding, containerWidth } = layoutOptions;\n    const targetColumnWidth = (containerWidth - spacing * (columns - 1) - 2 * padding * columns) / columns;\n    const { columnsGaps, columnsRatios, columnsModel } = computeColumnsModel({\n        photos,\n        layoutOptions,\n        targetColumnWidth\n    });\n    if (columnsModel.findIndex((columnModel)=>columnModel.findIndex(({ layout: { width, height } })=>width < 0 || height < 0) >= 0) >= 0) {\n        if (columns > 1) {\n            return computeLayout({\n                photos,\n                layoutOptions: {\n                    ...layoutOptions,\n                    columns: columns - 1\n                }\n            });\n        }\n        return void 0;\n    }\n    return {\n        columnsModel,\n        columnsGaps,\n        columnsRatios\n    };\n}\nfunction computeColumnsLayout({ photos, layoutOptions }) {\n    return computeLayout({\n        photos,\n        layoutOptions\n    });\n}\nfunction defaultRenderColumnContainer({ columnContainerProps, children }) {\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        ...columnContainerProps\n    }, children);\n}\nfunction cssColumnWidth(props) {\n    const { layoutOptions, columnIndex, columnsCount, columnsGaps, columnsRatios } = props;\n    const { layout, spacing, padding } = layoutOptions;\n    if (layout === \"masonry\" || !columnsGaps || !columnsRatios) {\n        return `calc((100% - ${spacing * (columnsCount - 1)}px) / ${columnsCount})`;\n    }\n    const totalRatio = columnsRatios.reduce((acc, ratio2)=>acc + ratio2, 0);\n    const totalAdjustedGaps = columnsRatios.reduce((acc, ratio2, index)=>acc + (columnsGaps[columnIndex] - columnsGaps[index]) * ratio2, 0);\n    return `calc((100% - ${round((columnsCount - 1) * spacing + 2 * columnsCount * padding + totalAdjustedGaps, 3)}px) * ${round(columnsRatios[columnIndex] / totalRatio, 5)} + ${2 * padding}px)`;\n}\nfunction ColumnContainerRenderer(props) {\n    const { layoutOptions, renderColumnContainer, children, columnContainerProps: { style, className, ...restColumnContainerProps } = {}, ...rest } = props;\n    const columnContainerProps = {\n        className: clsx(\"react-photo-album--column\", className),\n        style: {\n            display: \"flex\",\n            flexDirection: \"column\",\n            flexWrap: \"nowrap\",\n            alignItems: \"flex-start\",\n            width: cssColumnWidth(props),\n            justifyContent: layoutOptions.layout === \"columns\" ? \"space-between\" : \"flex-start\",\n            ...style\n        },\n        ...restColumnContainerProps\n    };\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, (renderColumnContainer != null ? renderColumnContainer : defaultRenderColumnContainer)({\n        layoutOptions,\n        columnContainerProps,\n        children,\n        ...rest\n    }));\n}\nfunction ColumnsLayout(props) {\n    const { photos, layoutOptions, renderPhoto, renderColumnContainer, componentsProps: { imageProps, columnContainerProps } } = props;\n    const columnsLayout = computeColumnsLayout({\n        photos,\n        layoutOptions\n    });\n    if (!columnsLayout) return null;\n    const { columnsModel, columnsRatios, columnsGaps } = columnsLayout;\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, columnsModel.map((column, columnIndex)=>/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ColumnContainerRenderer, {\n            key: `column-${columnIndex}`,\n            layoutOptions,\n            columnIndex,\n            columnsCount: columnsModel.length,\n            columnsGaps,\n            columnsRatios,\n            renderColumnContainer,\n            columnContainerProps\n        }, column.map(({ photo, layout })=>/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(PhotoRenderer, {\n                key: photo.key || photo.src,\n                photo,\n                layout,\n                layoutOptions,\n                renderPhoto,\n                imageProps\n            })))));\n}\nfunction computeMasonryLayout(props) {\n    const { photos, layoutOptions } = props;\n    const { columns, spacing, padding, containerWidth } = layoutOptions;\n    const columnWidth = (containerWidth - spacing * (columns - 1) - 2 * padding * columns) / columns;\n    if (columnWidth <= 0) {\n        return columns > 1 ? computeMasonryLayout({\n            ...props,\n            layoutOptions: {\n                ...layoutOptions,\n                columns: columns - 1\n            }\n        }) : void 0;\n    }\n    const columnsCurrentTopPositions = [];\n    for(let i = 0; i < columns; i += 1){\n        columnsCurrentTopPositions[i] = 0;\n    }\n    const columnsModel = photos.reduce((model, photo, index)=>{\n        const shortestColumn = columnsCurrentTopPositions.reduce((currentShortestColumn, item, i)=>item < columnsCurrentTopPositions[currentShortestColumn] - 1 ? i : currentShortestColumn, 0);\n        columnsCurrentTopPositions[shortestColumn] = columnsCurrentTopPositions[shortestColumn] + columnWidth / ratio(photo) + spacing + 2 * padding;\n        model[shortestColumn].push({\n            photo,\n            index\n        });\n        return model;\n    }, Array.from({\n        length: columns\n    }).map(()=>[]));\n    return columnsModel.map((column)=>column.map(({ photo, index }, photoIndex)=>({\n                photo,\n                layout: {\n                    width: columnWidth,\n                    height: columnWidth / ratio(photo),\n                    index,\n                    photoIndex,\n                    photosCount: column.length\n                }\n            })));\n}\nfunction MasonryLayout(props) {\n    const { photos, layoutOptions, renderPhoto, renderColumnContainer, componentsProps: { imageProps, columnContainerProps } } = props;\n    const masonryLayout = computeMasonryLayout({\n        photos,\n        layoutOptions\n    });\n    if (!masonryLayout) return null;\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, masonryLayout.map((column, columnIndex)=>/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ColumnContainerRenderer, {\n            key: `masonry-column-${columnIndex}`,\n            layoutOptions,\n            columnsCount: masonryLayout.length,\n            columnIndex,\n            renderColumnContainer,\n            columnContainerProps\n        }, column.map(({ photo, layout })=>/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(PhotoRenderer, {\n                key: photo.key || photo.src,\n                photo,\n                layout,\n                layoutOptions,\n                renderPhoto,\n                imageProps\n            })))));\n}\nfunction defaultRenderContainer({ containerProps, children, containerRef }) {\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n        ref: containerRef,\n        ...containerProps\n    }, children);\n}\nfunction ContainerRenderer(props) {\n    const { layout, renderContainer, children, containerRef, containerProps: { style, className, ...restContainerProps } = {} } = props;\n    const containerProps = {\n        className: clsx(\"react-photo-album\", `react-photo-album--${layout}`, className),\n        style: {\n            display: \"flex\",\n            flexWrap: \"nowrap\",\n            justifyContent: \"space-between\",\n            flexDirection: layout === \"rows\" ? \"column\" : \"row\",\n            ...style\n        },\n        ...restContainerProps\n    };\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, (renderContainer != null ? renderContainer : defaultRenderContainer)({\n        containerProps,\n        containerRef,\n        layout,\n        children\n    }));\n}\nfunction useArray(array) {\n    const ref = react__WEBPACK_IMPORTED_MODULE_0__.useRef(array);\n    if (!array || !ref.current || array.join() !== ref.current.join()) {\n        ref.current = array;\n    }\n    return ref.current;\n}\nfunction containerWidthReducer(state, { newContainerWidth, newScrollbarWidth }) {\n    const { containerWidth, scrollbarWidth } = state;\n    if (containerWidth !== void 0 && scrollbarWidth !== void 0 && newContainerWidth !== void 0 && newScrollbarWidth !== void 0 && newContainerWidth > containerWidth && newContainerWidth - containerWidth <= 20 && newScrollbarWidth < scrollbarWidth) {\n        return {\n            containerWidth,\n            scrollbarWidth: newScrollbarWidth\n        };\n    }\n    return containerWidth !== newContainerWidth || scrollbarWidth !== newScrollbarWidth ? {\n        containerWidth: newContainerWidth,\n        scrollbarWidth: newScrollbarWidth\n    } : state;\n}\nfunction resolveContainerWidth(el, breakpoints2) {\n    let width = el == null ? void 0 : el.clientWidth;\n    if (width !== void 0 && breakpoints2 && breakpoints2.length > 0) {\n        const sorted = [\n            ...breakpoints2.filter((x)=>x > 0)\n        ].sort((a, b)=>b - a);\n        sorted.push(Math.floor(sorted[sorted.length - 1] / 2));\n        const threshold = width;\n        width = sorted.find((breakpoint, index)=>breakpoint <= threshold || index === sorted.length - 1);\n    }\n    return width;\n}\nfunction useContainerWidth(breakpoints2, defaultContainerWidth) {\n    const [{ containerWidth }, dispatch] = react__WEBPACK_IMPORTED_MODULE_0__.useReducer(containerWidthReducer, {\n        containerWidth: defaultContainerWidth\n    });\n    const ref = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const observerRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\n    const containerRef = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((node)=>{\n        var _a;\n        (_a = observerRef.current) == null ? void 0 : _a.disconnect();\n        observerRef.current = void 0;\n        ref.current = node;\n        const updateWidth = ()=>dispatch({\n                newContainerWidth: resolveContainerWidth(ref.current, breakpoints2),\n                newScrollbarWidth: window.innerWidth - document.documentElement.clientWidth\n            });\n        updateWidth();\n        if (node && typeof ResizeObserver !== \"undefined\") {\n            observerRef.current = new ResizeObserver(updateWidth);\n            observerRef.current.observe(node);\n        }\n    }, [\n        breakpoints2\n    ]);\n    return {\n        containerRef,\n        containerWidth\n    };\n}\nconst breakpoints = Object.freeze([\n    1200,\n    600,\n    300,\n    0\n]);\nfunction unwrap(value, arg) {\n    return typeof value === \"function\" ? value(arg) : value;\n}\nfunction unwrapParameter(value, containerWidth) {\n    return typeof value !== \"undefined\" ? unwrap(value, containerWidth) : void 0;\n}\nfunction selectResponsiveValue(values, containerWidth) {\n    const index = breakpoints.findIndex((breakpoint)=>breakpoint <= containerWidth);\n    return unwrap(values[index >= 0 ? index : 0], containerWidth);\n}\nfunction resolveResponsiveParameter(parameter, containerWidth, values, minValue = 0) {\n    const value = unwrapParameter(parameter, containerWidth);\n    return Math.round(Math.max(value === void 0 ? selectResponsiveValue(values, containerWidth) : value, minValue));\n}\nfunction resolveLayoutOptions({ layout, onClick, containerWidth, targetRowHeight, rowConstraints, columns, spacing, padding, sizes }) {\n    return {\n        layout,\n        onClick,\n        containerWidth,\n        columns: resolveResponsiveParameter(columns, containerWidth, [\n            5,\n            4,\n            3,\n            2\n        ], 1),\n        spacing: resolveResponsiveParameter(spacing, containerWidth, [\n            20,\n            15,\n            10,\n            5\n        ]),\n        padding: resolveResponsiveParameter(padding, containerWidth, [\n            0,\n            0,\n            0,\n            0,\n            0\n        ]),\n        targetRowHeight: resolveResponsiveParameter(targetRowHeight, containerWidth, [\n            (w)=>w / 5,\n            (w)=>w / 4,\n            (w)=>w / 3,\n            (w)=>w / 2\n        ]),\n        rowConstraints: unwrapParameter(rowConstraints, containerWidth),\n        sizes\n    };\n}\nfunction resolveComponentsProps(props, containerWidth, layoutOptions) {\n    const { photos, componentsProps: componentsPropsProp } = props;\n    const componentsProps = unwrap(componentsPropsProp, containerWidth) || {};\n    if (layoutOptions) {\n        const { layout, spacing, padding, rowConstraints } = layoutOptions;\n        if (layout === \"rows\") {\n            const { singleRowMaxHeight } = rowConstraints || {};\n            if (singleRowMaxHeight) {\n                const maxWidth = Math.floor(photos.reduce((acc, { width, height })=>acc + width / height * singleRowMaxHeight - 2 * padding, padding * photos.length * 2 + spacing * (photos.length - 1)));\n                if (maxWidth > 0) {\n                    componentsProps.containerProps = componentsProps.containerProps || {};\n                    componentsProps.containerProps.style = {\n                        maxWidth,\n                        ...componentsProps.containerProps.style\n                    };\n                }\n            }\n        }\n    }\n    return componentsProps;\n}\nfunction renderLayout(props, componentsProps, layoutOptions) {\n    const { photos, layout, renderPhoto, renderRowContainer, renderColumnContainer } = props;\n    const commonLayoutProps = {\n        photos,\n        renderPhoto,\n        componentsProps\n    };\n    if (layout === \"rows\") {\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(RowsLayout, {\n            layoutOptions,\n            renderRowContainer,\n            ...commonLayoutProps\n        });\n    }\n    if (layout === \"columns\") {\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ColumnsLayout, {\n            layoutOptions,\n            renderColumnContainer,\n            ...commonLayoutProps\n        });\n    }\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(MasonryLayout, {\n        layoutOptions,\n        renderColumnContainer,\n        ...commonLayoutProps\n    });\n}\nfunction PhotoAlbum(props) {\n    const { photos, layout, renderContainer, defaultContainerWidth, breakpoints: breakpoints2 } = props;\n    const { containerRef, containerWidth } = useContainerWidth(useArray(breakpoints2), defaultContainerWidth);\n    if (!layout || ![\n        \"rows\",\n        \"columns\",\n        \"masonry\"\n    ].includes(layout) || !Array.isArray(photos)) return null;\n    const layoutOptions = containerWidth ? resolveLayoutOptions({\n        containerWidth,\n        ...props\n    }) : void 0;\n    const componentsProps = resolveComponentsProps(props, containerWidth, layoutOptions);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(ContainerRenderer, {\n        layout,\n        containerRef,\n        renderContainer,\n        containerProps: componentsProps.containerProps\n    }, layoutOptions && renderLayout(props, componentsProps, layoutOptions));\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtcGhvdG8tYWxidW0vZGlzdC9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OytKQUMrQjtBQUMvQixTQUFTQyxNQUFNLEVBQUVDLEtBQUssRUFBRUMsTUFBTSxFQUFFO0lBQzlCLE9BQU9ELFFBQVFDO0FBQ2pCO0FBQ0EsU0FBU0MsTUFBTUMsS0FBSyxFQUFFQyxXQUFXLENBQUM7SUFDaEMsTUFBTUMsU0FBUyxNQUFNRDtJQUNyQixPQUFPRSxLQUFLSixLQUFLLENBQUMsQ0FBQ0MsUUFBUUksT0FBT0MsT0FBTyxJQUFJSCxVQUFVQTtBQUN6RDtBQUNBLFNBQVNJLDBCQUEwQkMsSUFBSTtJQUNyQyxPQUFPLENBQUNDLEdBQUdDLElBQU1GLEtBQUtFLEtBQUtGLEtBQUtDO0FBQ2xDO0FBQ0EsTUFBTUU7SUFDSkMsWUFBWUMsVUFBVSxDQUFFO1FBQ3RCLElBQUksQ0FBQ0EsVUFBVSxHQUFHQTtRQUNsQixJQUFJLENBQUNDLElBQUksR0FBRyxFQUFFO1FBQ2QsSUFBSSxDQUFDQyxDQUFDLEdBQUc7SUFDWDtJQUNBQyxRQUFRQyxDQUFDLEVBQUVDLENBQUMsRUFBRTtRQUNaLE9BQU8sSUFBSSxDQUFDTCxVQUFVLENBQUMsSUFBSSxDQUFDQyxJQUFJLENBQUNHLEVBQUUsRUFBRSxJQUFJLENBQUNILElBQUksQ0FBQ0ksRUFBRSxJQUFJO0lBQ3ZEO0lBQ0FDLEtBQUtGLENBQUMsRUFBRUMsQ0FBQyxFQUFFO1FBQ1QsTUFBTUUsT0FBTyxJQUFJLENBQUNOLElBQUksQ0FBQ0csRUFBRTtRQUN6QixJQUFJLENBQUNILElBQUksQ0FBQ0csRUFBRSxHQUFHLElBQUksQ0FBQ0gsSUFBSSxDQUFDSSxFQUFFO1FBQzNCLElBQUksQ0FBQ0osSUFBSSxDQUFDSSxFQUFFLEdBQUdFO0lBQ2pCO0lBQ0FDLEtBQUtKLENBQUMsRUFBRTtRQUNOLElBQUlLLElBQUlMO1FBQ1IsSUFBSU0sS0FBS25CLEtBQUtvQixLQUFLLENBQUNGLElB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LGlCQUFpQjtRQUN0QjtJQUVKO0lBQ0EsSUFBSTFMLFdBQVcsV0FBVztRQUN4QixxQkFBT3BHLGdEQUFtQixDQUN4QjZOLGVBQ0E7WUFDRXhJO1lBQ0FzSTtZQUNBLEdBQUdtRSxpQkFBaUI7UUFDdEI7SUFFSjtJQUNBLHFCQUFPOVIsZ0RBQW1CLENBQ3hCcU8sZUFDQTtRQUNFaEo7UUFDQXNJO1FBQ0EsR0FBR21FLGlCQUFpQjtJQUN0QjtBQUVKO0FBQ0EsU0FBU0MsV0FBV3pKLEtBQUs7SUFDdkIsTUFBTSxFQUFFckUsTUFBTSxFQUFFbUMsTUFBTSxFQUFFd0ksZUFBZSxFQUFFbUIscUJBQXFCLEVBQUVhLGFBQWFwQixZQUFZLEVBQUUsR0FBR2xIO0lBQzlGLE1BQU0sRUFBRW1HLFlBQVksRUFBRXRLLGNBQWMsRUFBRSxHQUFHMkwsa0JBQWtCaEIsU0FBU1UsZUFBZU87SUFDbkYsSUFBSSxDQUFDM0osVUFBVSxDQUFDO1FBQUM7UUFBUTtRQUFXO0tBQVUsQ0FBQzRMLFFBQVEsQ0FBQzVMLFdBQVcsQ0FBQ3lHLE1BQU1vRixPQUFPLENBQUNoTyxTQUFTLE9BQU87SUFDbEcsTUFBTW9CLGdCQUFnQmxCLGlCQUFpQm9OLHFCQUFxQjtRQUFFcE47UUFBZ0IsR0FBR21FLEtBQUs7SUFBQyxLQUFLLEtBQUs7SUFDakcsTUFBTXdDLGtCQUFrQjJHLHVCQUF1Qm5KLE9BQU9uRSxnQkFBZ0JrQjtJQUN0RSxxQkFBT3JGLGdEQUFtQixDQUN4QjJPLG1CQUNBO1FBQ0V2STtRQUNBcUk7UUFDQUc7UUFDQUosZ0JBQWdCMUQsZ0JBQWdCMEQsY0FBYztJQUNoRCxHQUNBbkosaUJBQWlCd00sYUFBYXZKLE9BQU93QyxpQkFBaUJ6RjtBQUUxRDtBQU9FIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dGpzLWV4ZXJjaXNlLy4vbm9kZV9tb2R1bGVzL3JlYWN0LXBob3RvLWFsYnVtL2Rpc3QvaW5kZXgubWpzP2I0NjQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2UgY2xpZW50XCI7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmZ1bmN0aW9uIHJhdGlvKHsgd2lkdGgsIGhlaWdodCB9KSB7XG4gIHJldHVybiB3aWR0aCAvIGhlaWdodDtcbn1cbmZ1bmN0aW9uIHJvdW5kKHZhbHVlLCBkZWNpbWFscyA9IDApIHtcbiAgY29uc3QgZmFjdG9yID0gMTAgKiogZGVjaW1hbHM7XG4gIHJldHVybiBNYXRoLnJvdW5kKCh2YWx1ZSArIE51bWJlci5FUFNJTE9OKSAqIGZhY3RvcikgLyBmYWN0b3I7XG59XG5mdW5jdGlvbiByYW5raW5nRnVuY3Rpb25Db21wYXJhdG9yKHJhbmspIHtcbiAgcmV0dXJuIChhLCBiKSA9PiByYW5rKGIpIC0gcmFuayhhKTtcbn1cbmNsYXNzIE1pbkhlYXAge1xuICBjb25zdHJ1Y3Rvcihjb21wYXJhdG9yKSB7XG4gICAgdGhpcy5jb21wYXJhdG9yID0gY29tcGFyYXRvcjtcbiAgICB0aGlzLmhlYXAgPSBbXTtcbiAgICB0aGlzLm4gPSAwO1xuICB9XG4gIGdyZWF0ZXIoaSwgaikge1xuICAgIHJldHVybiB0aGlzLmNvbXBhcmF0b3IodGhpcy5oZWFwW2ldLCB0aGlzLmhlYXBbal0pIDwgMDtcbiAgfVxuICBzd2FwKGksIGopIHtcbiAgICBjb25zdCB0ZW1wID0gdGhpcy5oZWFwW2ldO1xuICAgIHRoaXMuaGVhcFtpXSA9IHRoaXMuaGVhcFtqXTtcbiAgICB0aGlzLmhlYXBbal0gPSB0ZW1wO1xuICB9XG4gIHN3aW0oaSkge1xuICAgIGxldCBrID0gaTtcbiAgICBsZXQgazIgPSBNYXRoLmZsb29yKGsgLyAyKTtcbiAgICB3aGlsZSAoayA+IDEgJiYgdGhpcy5ncmVhdGVyKGsyLCBrKSkge1xuICAgICAgdGhpcy5zd2FwKGsyLCBrKTtcbiAgICAgIGsgPSBrMjtcbiAgICAgIGsyID0gTWF0aC5mbG9vcihrIC8gMik7XG4gICAgfVxuICB9XG4gIHNpbmsoaSkge1xuICAgIGxldCBrID0gaTtcbiAgICBsZXQgazIgPSBrICogMjtcbiAgICB3aGlsZSAoazIgPD0gdGhpcy5uKSB7XG4gICAgICBpZiAoazIgPCB0aGlzLm4gJiYgdGhpcy5ncmVhdGVyKGsyLCBrMiArIDEpKSBrMiArPSAxO1xuICAgICAgaWYgKCF0aGlzLmdyZWF0ZXIoaywgazIpKSBicmVhaztcbiAgICAgIHRoaXMuc3dhcChrLCBrMik7XG4gICAgICBrID0gazI7XG4gICAgICBrMiA9IGsgKiAyO1xuICAgIH1cbiAgfVxuICBwdXNoKGVsZW1lbnQpIHtcbiAgICB0aGlzLm4gKz0gMTtcbiAgICB0aGlzLmhlYXBbdGhpcy5uXSA9IGVsZW1lbnQ7XG4gICAgdGhpcy5zd2ltKHRoaXMubik7XG4gIH1cbiAgcG9wKCkge1xuICAgIGlmICh0aGlzLm4gPT09IDApIHJldHVybiB2b2lkIDA7XG4gICAgdGhpcy5zd2FwKDEsIHRoaXMubik7XG4gICAgdGhpcy5uIC09IDE7XG4gICAgY29uc3QgbWF4ID0gdGhpcy5oZWFwLnBvcCgpO1xuICAgIHRoaXMuc2luaygxKTtcbiAgICByZXR1cm4gbWF4O1xuICB9XG4gIHNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMubjtcbiAgfVxufVxuZnVuY3Rpb24gYnVpbGRQcmVjZWRlbnRzTWFwKGdyYXBoLCBzdGFydE5vZGUsIGVuZE5vZGUpIHtcbiAgY29uc3QgcHJlY2VkZW50c01hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gIGNvbnN0IHZpc2l0ZWQgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBjb25zdCBzdG9yZWRTaG9ydGVzdFBhdGhzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgc3RvcmVkU2hvcnRlc3RQYXRocy5zZXQoc3RhcnROb2RlLCAwKTtcbiAgY29uc3QgcXVldWUgPSBuZXcgTWluSGVhcChyYW5raW5nRnVuY3Rpb25Db21wYXJhdG9yKChlbCkgPT4gZWwud2VpZ2h0KSk7XG4gIHF1ZXVlLnB1c2goeyBpZDogc3RhcnROb2RlLCB3ZWlnaHQ6IDAgfSk7XG4gIHdoaWxlIChxdWV1ZS5zaXplKCkgPiAwKSB7XG4gICAgY29uc3QgeyBpZCwgd2VpZ2h0IH0gPSBxdWV1ZS5wb3AoKTtcbiAgICBpZiAoIXZpc2l0ZWQuaGFzKGlkKSkge1xuICAgICAgY29uc3QgbmVpZ2hib3JpbmdOb2RlcyA9IGdyYXBoKGlkKTtcbiAgICAgIHZpc2l0ZWQuYWRkKGlkKTtcbiAgICAgIG5laWdoYm9yaW5nTm9kZXMuZm9yRWFjaCgobmVpZ2hib3JXZWlnaHQsIG5laWdoYm9yKSA9PiB7XG4gICAgICAgIGNvbnN0IG5ld1dlaWdodCA9IHdlaWdodCArIG5laWdoYm9yV2VpZ2h0O1xuICAgICAgICBjb25zdCBjdXJyZW50SWQgPSBwcmVjZWRlbnRzTWFwLmdldChuZWlnaGJvcik7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRXZWlnaHQgPSBzdG9yZWRTaG9ydGVzdFBhdGhzLmdldChuZWlnaGJvcik7XG4gICAgICAgIGlmIChjdXJyZW50V2VpZ2h0ID09PSB2b2lkIDAgfHwgY3VycmVudFdlaWdodCA+IG5ld1dlaWdodCAmJiAoY3VycmVudFdlaWdodCAvIG5ld1dlaWdodCA+IDEuMDA1IHx8IGN1cnJlbnRJZCAhPT0gdm9pZCAwICYmIGN1cnJlbnRJZCA8IGlkKSkge1xuICAgICAgICAgIHN0b3JlZFNob3J0ZXN0UGF0aHMuc2V0KG5laWdoYm9yLCBuZXdXZWlnaHQpO1xuICAgICAgICAgIHF1ZXVlLnB1c2goeyBpZDogbmVpZ2hib3IsIHdlaWdodDogbmV3V2VpZ2h0IH0pO1xuICAgICAgICAgIHByZWNlZGVudHNNYXAuc2V0KG5laWdoYm9yLCBpZCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3RvcmVkU2hvcnRlc3RQYXRocy5oYXMoZW5kTm9kZSkgPyBwcmVjZWRlbnRzTWFwIDogdm9pZCAwO1xufVxuZnVuY3Rpb24gZ2V0UGF0aEZyb21QcmVjZWRlbnRzTWFwKHByZWNlZGVudHNNYXAsIGVuZE5vZGUpIHtcbiAgY29uc3Qgbm9kZXMgPSBbXTtcbiAgZm9yIChsZXQgbm9kZSA9IGVuZE5vZGU7IG5vZGUgIT09IHZvaWQgMDsgbm9kZSA9IHByZWNlZGVudHNNYXAuZ2V0KG5vZGUpKSB7XG4gICAgbm9kZXMucHVzaChub2RlKTtcbiAgfVxuICByZXR1cm4gbm9kZXMucmV2ZXJzZSgpO1xufVxuZnVuY3Rpb24gZmluZFNob3J0ZXN0UGF0aChncmFwaCwgc3RhcnROb2RlLCBlbmROb2RlKSB7XG4gIGNvbnN0IHByZWNlZGVudHNNYXAgPSBidWlsZFByZWNlZGVudHNNYXAoZ3JhcGgsIHN0YXJ0Tm9kZSwgZW5kTm9kZSk7XG4gIHJldHVybiBwcmVjZWRlbnRzTWFwID8gZ2V0UGF0aEZyb21QcmVjZWRlbnRzTWFwKHByZWNlZGVudHNNYXAsIGVuZE5vZGUpIDogdm9pZCAwO1xufVxuZnVuY3Rpb24gZmluZElkZWFsTm9kZVNlYXJjaCh7XG4gIHBob3RvcyxcbiAgdGFyZ2V0Um93SGVpZ2h0LFxuICBjb250YWluZXJXaWR0aFxufSkge1xuICBjb25zdCBtaW5SYXRpbyA9IHBob3Rvcy5yZWR1Y2UoKGFjYywgcGhvdG8pID0+IE1hdGgubWluKHJhdGlvKHBob3RvKSwgYWNjKSwgTnVtYmVyLk1BWF9WQUxVRSk7XG4gIHJldHVybiByb3VuZChjb250YWluZXJXaWR0aCAvIHRhcmdldFJvd0hlaWdodCAvIG1pblJhdGlvKSArIDI7XG59XG5mdW5jdGlvbiBnZXRDb21tb25IZWlnaHQocm93LCBjb250YWluZXJXaWR0aCwgc3BhY2luZywgcGFkZGluZykge1xuICBjb25zdCByb3dXaWR0aCA9IGNvbnRhaW5lcldpZHRoIC0gKHJvdy5sZW5ndGggLSAxKSAqIHNwYWNpbmcgLSAyICogcGFkZGluZyAqIHJvdy5sZW5ndGg7XG4gIGNvbnN0IHRvdGFsQXNwZWN0UmF0aW8gPSByb3cucmVkdWNlKChhY2MsIHBob3RvKSA9PiBhY2MgKyByYXRpbyhwaG90byksIDApO1xuICByZXR1cm4gcm93V2lkdGggLyB0b3RhbEFzcGVjdFJhdGlvO1xufVxuZnVuY3Rpb24gY29zdChwaG90b3MsIGksIGosIHdpZHRoLCB0YXJnZXRSb3dIZWlnaHQsIHNwYWNpbmcsIHBhZGRpbmcpIHtcbiAgY29uc3Qgcm93ID0gcGhvdG9zLnNsaWNlKGksIGopO1xuICBjb25zdCBjb21tb25IZWlnaHQgPSBnZXRDb21tb25IZWlnaHQocm93LCB3aWR0aCwgc3BhY2luZywgcGFkZGluZyk7XG4gIHJldHVybiBjb21tb25IZWlnaHQgPiAwID8gKGNvbW1vbkhlaWdodCAtIHRhcmdldFJvd0hlaWdodCkgKiogMiAqIHJvdy5sZW5ndGggOiB2b2lkIDA7XG59XG5mdW5jdGlvbiBtYWtlR2V0Um93TmVpZ2hib3JzKHtcbiAgcGhvdG9zLFxuICBsYXlvdXRPcHRpb25zLFxuICB0YXJnZXRSb3dIZWlnaHQsXG4gIGxpbWl0Tm9kZVNlYXJjaCxcbiAgcm93Q29uc3RyYWludHNcbn0pIHtcbiAgcmV0dXJuIChub2RlKSA9PiB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBjb25zdCB7IGNvbnRhaW5lcldpZHRoLCBzcGFjaW5nLCBwYWRkaW5nIH0gPSBsYXlvdXRPcHRpb25zO1xuICAgIGNvbnN0IHJlc3VsdHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHJlc3VsdHMuc2V0KG5vZGUsIDApO1xuICAgIGNvbnN0IHN0YXJ0T2Zmc2V0ID0gKF9hID0gcm93Q29uc3RyYWludHMgPT0gbnVsbCA/IHZvaWQgMCA6IHJvd0NvbnN0cmFpbnRzLm1pblBob3RvcykgIT0gbnVsbCA/IF9hIDogMTtcbiAgICBjb25zdCBlbmRPZmZzZXQgPSBNYXRoLm1pbihsaW1pdE5vZGVTZWFyY2gsIChfYiA9IHJvd0NvbnN0cmFpbnRzID09IG51bGwgPyB2b2lkIDAgOiByb3dDb25zdHJhaW50cy5tYXhQaG90b3MpICE9IG51bGwgPyBfYiA6IEluZmluaXR5KTtcbiAgICBmb3IgKGxldCBpID0gbm9kZSArIHN0YXJ0T2Zmc2V0OyBpIDwgcGhvdG9zLmxlbmd0aCArIDE7IGkgKz0gMSkge1xuICAgICAgaWYgKGkgLSBub2RlID4gZW5kT2Zmc2V0KSBicmVhaztcbiAgICAgIGNvbnN0IGN1cnJlbnRDb3N0ID0gY29zdChwaG90b3MsIG5vZGUsIGksIGNvbnRhaW5lcldpZHRoLCB0YXJnZXRSb3dIZWlnaHQsIHNwYWNpbmcsIHBhZGRpbmcpO1xuICAgICAgaWYgKGN1cnJlbnRDb3N0ID09PSB2b2lkIDApIGJyZWFrO1xuICAgICAgcmVzdWx0cy5zZXQoaSwgY3VycmVudENvc3QpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfTtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVSb3dzTGF5b3V0KHtcbiAgcGhvdG9zLFxuICBsYXlvdXRPcHRpb25zXG59KSB7XG4gIGNvbnN0IHsgc3BhY2luZywgcGFkZGluZywgY29udGFpbmVyV2lkdGgsIHRhcmdldFJvd0hlaWdodCwgcm93Q29uc3RyYWludHMgfSA9IGxheW91dE9wdGlvbnM7XG4gIGNvbnN0IGxpbWl0Tm9kZVNlYXJjaCA9IGZpbmRJZGVhbE5vZGVTZWFyY2goeyBwaG90b3MsIGNvbnRhaW5lcldpZHRoLCB0YXJnZXRSb3dIZWlnaHQgfSk7XG4gIGNvbnN0IGdldE5laWdoYm9ycyA9IG1ha2VHZXRSb3dOZWlnaGJvcnMoe1xuICAgIHBob3RvcyxcbiAgICBsYXlvdXRPcHRpb25zLFxuICAgIHRhcmdldFJvd0hlaWdodCxcbiAgICBsaW1pdE5vZGVTZWFyY2gsXG4gICAgcm93Q29uc3RyYWludHNcbiAgfSk7XG4gIGNvbnN0IHBhdGggPSBmaW5kU2hvcnRlc3RQYXRoKGdldE5laWdoYm9ycywgMCwgcGhvdG9zLmxlbmd0aCk7XG4gIGlmIChwYXRoID09PSB2b2lkIDApIHJldHVybiB2b2lkIDA7XG4gIGNvbnN0IGxheW91dCA9IFtdO1xuICBmb3IgKGxldCBpID0gMTsgaSA8IHBhdGgubGVuZ3RoOyBpICs9IDEpIHtcbiAgICBjb25zdCByb3cgPSBwaG90b3MubWFwKChwaG90bywgaW5kZXgpID0+ICh7IHBob3RvLCBpbmRleCB9KSkuc2xpY2UocGF0aFtpIC0gMV0sIHBhdGhbaV0pO1xuICAgIGNvbnN0IGhlaWdodCA9IGdldENvbW1vbkhlaWdodChcbiAgICAgIHJvdy5tYXAoKHsgcGhvdG8gfSkgPT4gcGhvdG8pLFxuICAgICAgY29udGFpbmVyV2lkdGgsXG4gICAgICBzcGFjaW5nLFxuICAgICAgcGFkZGluZ1xuICAgICk7XG4gICAgbGF5b3V0LnB1c2goXG4gICAgICByb3cubWFwKCh7IHBob3RvLCBpbmRleCB9LCBwaG90b0luZGV4KSA9PiAoe1xuICAgICAgICBwaG90byxcbiAgICAgICAgbGF5b3V0OiB7XG4gICAgICAgICAgaGVpZ2h0LFxuICAgICAgICAgIHdpZHRoOiBoZWlnaHQgKiByYXRpbyhwaG90byksXG4gICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgcGhvdG9JbmRleCxcbiAgICAgICAgICBwaG90b3NDb3VudDogcm93Lmxlbmd0aFxuICAgICAgICB9XG4gICAgICB9KSlcbiAgICApO1xuICB9XG4gIHJldHVybiBsYXlvdXQ7XG59XG5mdW5jdGlvbiBjbHN4KC4uLmNsYXNzZXMpIHtcbiAgcmV0dXJuIFsuLi5jbGFzc2VzXS5maWx0ZXIoKGNscykgPT4gQm9vbGVhbihjbHMpKS5qb2luKFwiIFwiKTtcbn1cbmZ1bmN0aW9uIGNhbGNXaWR0aChiYXNlLCBwaG90b0xheW91dCwgbGF5b3V0T3B0aW9ucykge1xuICBjb25zdCB7IHdpZHRoLCBwaG90b3NDb3VudCB9ID0gcGhvdG9MYXlvdXQ7XG4gIGNvbnN0IHsgbGF5b3V0LCBzcGFjaW5nLCBwYWRkaW5nLCBjb250YWluZXJXaWR0aCB9ID0gbGF5b3V0T3B0aW9ucztcbiAgY29uc3QgY291bnQgPSBsYXlvdXQgPT09IFwicm93c1wiID8gcGhvdG9zQ291bnQgOiBsYXlvdXRPcHRpb25zLmNvbHVtbnM7XG4gIGNvbnN0IGdhcHMgPSBzcGFjaW5nICogKGNvdW50IC0gMSkgKyAyICogcGFkZGluZyAqIGNvdW50O1xuICByZXR1cm4gYGNhbGMoKCR7YmFzZX0gLSAke2dhcHN9cHgpIC8gJHtyb3VuZCgoY29udGFpbmVyV2lkdGggLSBnYXBzKSAvIHdpZHRoLCA1KX0pYDtcbn1cbmZ1bmN0aW9uIGNzc1Bob3RvV2lkdGgobGF5b3V0LCBsYXlvdXRPcHRpb25zKSB7XG4gIHJldHVybiBsYXlvdXRPcHRpb25zLmxheW91dCAhPT0gXCJyb3dzXCIgPyBgY2FsYygxMDAlIC0gJHsyICogbGF5b3V0T3B0aW9ucy5wYWRkaW5nfXB4KWAgOiBjYWxjV2lkdGgoXCIxMDAlXCIsIGxheW91dCwgbGF5b3V0T3B0aW9ucyk7XG59XG5mdW5jdGlvbiBjYWxjdWxhdGVTaXplc1ZhbHVlKHNpemUsIGxheW91dCwgbGF5b3V0T3B0aW9ucykge1xuICB2YXIgX2EsIF9iO1xuICByZXR1cm4gY2FsY1dpZHRoKChfYiA9IChfYSA9IHNpemUubWF0Y2goL15cXHMqY2FsY1xcKCguKilcXClcXHMqJC8pKSA9PSBudWxsID8gdm9pZCAwIDogX2FbMV0pICE9IG51bGwgPyBfYiA6IHNpemUsIGxheW91dCwgbGF5b3V0T3B0aW9ucyk7XG59XG5mdW5jdGlvbiBzcmNTZXRBbmRTaXplcyhwaG90bywgbGF5b3V0LCBsYXlvdXRPcHRpb25zKSB7XG4gIHZhciBfYTtcbiAgbGV0IHNyY1NldDtcbiAgbGV0IHNpemVzO1xuICBjb25zdCBpbWFnZXMgPSBwaG90by5zcmNTZXQgfHwgcGhvdG8uaW1hZ2VzO1xuICBpZiAoaW1hZ2VzICYmIGltYWdlcy5sZW5ndGggPiAwKSB7XG4gICAgc3JjU2V0ID0gaW1hZ2VzLmNvbmNhdChcbiAgICAgICFpbWFnZXMuZmluZCgoeyB3aWR0aCB9KSA9PiB3aWR0aCA9PT0gcGhvdG8ud2lkdGgpID8gW3sgc3JjOiBwaG90by5zcmMsIHdpZHRoOiBwaG90by53aWR0aCwgaGVpZ2h0OiBwaG90by5oZWlnaHQgfV0gOiBbXVxuICAgICkuc29ydCgoZmlyc3QsIHNlY29uZCkgPT4gZmlyc3Qud2lkdGggLSBzZWNvbmQud2lkdGgpLm1hcCgoaW1hZ2UpID0+IGAke2ltYWdlLnNyY30gJHtpbWFnZS53aWR0aH13YCkuam9pbihcIiwgXCIpO1xuICB9XG4gIGlmICgoX2EgPSBsYXlvdXRPcHRpb25zLnNpemVzKSA9PSBudWxsID8gdm9pZCAwIDogX2Euc2l6ZSkge1xuICAgIHNpemVzID0gKGxheW91dE9wdGlvbnMuc2l6ZXMuc2l6ZXMgfHwgW10pLm1hcCgoeyB2aWV3cG9ydCwgc2l6ZSB9KSA9PiBgJHt2aWV3cG9ydH0gJHtjYWxjdWxhdGVTaXplc1ZhbHVlKHNpemUsIGxheW91dCwgbGF5b3V0T3B0aW9ucyl9YCkuY29uY2F0KGNhbGN1bGF0ZVNpemVzVmFsdWUobGF5b3V0T3B0aW9ucy5zaXplcy5zaXplLCBsYXlvdXQsIGxheW91dE9wdGlvbnMpKS5qb2luKFwiLCBcIik7XG4gIH0gZWxzZSB7XG4gICAgc2l6ZXMgPSBgJHtNYXRoLmNlaWwobGF5b3V0LndpZHRoIC8gbGF5b3V0T3B0aW9ucy5jb250YWluZXJXaWR0aCAqIDEwMCl9dndgO1xuICB9XG4gIHJldHVybiB7IHNyY1NldCwgc2l6ZXMgfTtcbn1cbmZ1bmN0aW9uIFBob3RvUmVuZGVyZXIocHJvcHMpIHtcbiAgdmFyIF9hLCBfYjtcbiAgY29uc3QgeyBwaG90bywgbGF5b3V0LCBsYXlvdXRPcHRpb25zLCBpbWFnZVByb3BzOiB7IHN0eWxlLCBjbGFzc05hbWUsIC4uLnJlc3RJbWFnZVByb3BzIH0gPSB7fSwgcmVuZGVyUGhvdG8gfSA9IHByb3BzO1xuICBjb25zdCB7IG9uQ2xpY2sgfSA9IGxheW91dE9wdGlvbnM7XG4gIGNvbnN0IGltYWdlU3R5bGUgPSB7XG4gICAgZGlzcGxheTogXCJibG9ja1wiLFxuICAgIGJveFNpemluZzogXCJjb250ZW50LWJveFwiLFxuICAgIHdpZHRoOiBjc3NQaG90b1dpZHRoKGxheW91dCwgbGF5b3V0T3B0aW9ucyksXG4gICAgaGVpZ2h0OiBcImF1dG9cIixcbiAgICBhc3BlY3RSYXRpbzogYCR7cGhvdG8ud2lkdGh9IC8gJHtwaG90by5oZWlnaHR9YCxcbiAgICAuLi5sYXlvdXRPcHRpb25zLnBhZGRpbmcgPyB7IHBhZGRpbmc6IGAke2xheW91dE9wdGlvbnMucGFkZGluZ31weGAgfSA6IG51bGwsXG4gICAgLi4uKGxheW91dE9wdGlvbnMubGF5b3V0ID09PSBcImNvbHVtbnNcIiB8fCBsYXlvdXRPcHRpb25zLmxheW91dCA9PT0gXCJtYXNvbnJ5XCIpICYmIGxheW91dC5waG90b0luZGV4IDwgbGF5b3V0LnBob3Rvc0NvdW50IC0gMSA/IHsgbWFyZ2luQm90dG9tOiBgJHtsYXlvdXRPcHRpb25zLnNwYWNpbmd9cHhgIH0gOiBudWxsLFxuICAgIC4uLm9uQ2xpY2sgPyB7IGN1cnNvcjogXCJwb2ludGVyXCIgfSA6IG51bGwsXG4gICAgLi4uc3R5bGVcbiAgfTtcbiAgY29uc3QgaGFuZGxlQ2xpY2sgPSBvbkNsaWNrID8gKGV2ZW50KSA9PiB7XG4gICAgb25DbGljayh7IGV2ZW50LCBwaG90bywgaW5kZXg6IGxheW91dC5pbmRleCB9KTtcbiAgfSA6IHZvaWQgMDtcbiAgY29uc3QgaW1hZ2VQcm9wcyA9IHtcbiAgICBzcmM6IHBob3RvLnNyYyxcbiAgICBhbHQ6IChfYSA9IHBob3RvLmFsdCkgIT0gbnVsbCA/IF9hIDogXCJcIixcbiAgICB0aXRsZTogcGhvdG8udGl0bGUsXG4gICAgb25DbGljazogaGFuZGxlQ2xpY2ssXG4gICAgc3R5bGU6IGltYWdlU3R5bGUsXG4gICAgY2xhc3NOYW1lOiBjbHN4KFwicmVhY3QtcGhvdG8tYWxidW0tLXBob3RvXCIsIGNsYXNzTmFtZSksXG4gICAgbG9hZGluZzogXCJsYXp5XCIsXG4gICAgZGVjb2Rpbmc6IFwiYXN5bmNcIixcbiAgICAuLi5zcmNTZXRBbmRTaXplcyhwaG90bywgbGF5b3V0LCBsYXlvdXRPcHRpb25zKSxcbiAgICAuLi5yZXN0SW1hZ2VQcm9wc1xuICB9O1xuICBjb25zdCByZW5kZXJEZWZhdWx0UGhvdG8gPSAob3B0aW9ucykgPT4ge1xuICAgIGNvbnN0IHsgc3JjLCBhbHQsIHNyY1NldCwgc2l6ZXMsIHN0eWxlOiB1bndyYXBwZWRTdHlsZSwgLi4ucmVzdCB9ID0gaW1hZ2VQcm9wcztcbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgIFwiaW1nXCIsXG4gICAgICB7XG4gICAgICAgIGFsdCxcbiAgICAgICAgLi4uc3JjU2V0ID8geyBzcmNTZXQsIHNpemVzIH0gOiBudWxsLFxuICAgICAgICBzcmMsXG4gICAgICAgIHN0eWxlOiAob3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy53cmFwcGVkKSA/IHsgZGlzcGxheTogXCJibG9ja1wiLCB3aWR0aDogXCIxMDAlXCIsIGhlaWdodDogXCIxMDAlXCIgfSA6IHVud3JhcHBlZFN0eWxlLFxuICAgICAgICAuLi5yZXN0XG4gICAgICB9XG4gICAgKTtcbiAgfTtcbiAgY29uc3Qgd3JhcHBlclN0eWxlID0gKCh7IGRpc3BsYXksIGJveFNpemluZywgd2lkdGgsIGFzcGVjdFJhdGlvLCBwYWRkaW5nLCBtYXJnaW5Cb3R0b20sIGN1cnNvciB9KSA9PiAoe1xuICAgIGRpc3BsYXksXG4gICAgYm94U2l6aW5nLFxuICAgIHdpZHRoLFxuICAgIGFzcGVjdFJhdGlvLFxuICAgIHBhZGRpbmcsXG4gICAgbWFyZ2luQm90dG9tLFxuICAgIGN1cnNvclxuICB9KSkoaW1hZ2VTdHlsZSk7XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLCAoX2IgPSByZW5kZXJQaG90byA9PSBudWxsID8gdm9pZCAwIDogcmVuZGVyUGhvdG8oe1xuICAgIHBob3RvLFxuICAgIGxheW91dCxcbiAgICBsYXlvdXRPcHRpb25zLFxuICAgIGltYWdlUHJvcHMsXG4gICAgcmVuZGVyRGVmYXVsdFBob3RvLFxuICAgIHdyYXBwZXJTdHlsZVxuICB9KSkgIT0gbnVsbCA/IF9iIDogcmVuZGVyRGVmYXVsdFBob3RvKCkpO1xufVxuZnVuY3Rpb24gZGVmYXVsdFJlbmRlclJvd0NvbnRhaW5lcih7XG4gIHJvd0NvbnRhaW5lclByb3BzLFxuICBjaGlsZHJlblxufSkge1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IC4uLnJvd0NvbnRhaW5lclByb3BzIH0sIGNoaWxkcmVuKTtcbn1cbmZ1bmN0aW9uIFJvd0NvbnRhaW5lclJlbmRlcmVyKHByb3BzKSB7XG4gIGNvbnN0IHtcbiAgICBsYXlvdXRPcHRpb25zLFxuICAgIHJvd0luZGV4LFxuICAgIHJvd3NDb3VudCxcbiAgICByZW5kZXJSb3dDb250YWluZXIsXG4gICAgcm93Q29udGFpbmVyUHJvcHM6IHsgc3R5bGUsIGNsYXNzTmFtZSwgLi4ucmVzdFJvd0NvbnRhaW5lclByb3BzIH0gPSB7fSxcbiAgICBjaGlsZHJlblxuICB9ID0gcHJvcHM7XG4gIGNvbnN0IHJvd0NvbnRhaW5lclByb3BzID0ge1xuICAgIGNsYXNzTmFtZTogY2xzeChcInJlYWN0LXBob3RvLWFsYnVtLS1yb3dcIiwgY2xhc3NOYW1lKSxcbiAgICBzdHlsZToge1xuICAgICAgZGlzcGxheTogXCJmbGV4XCIsXG4gICAgICBmbGV4RGlyZWN0aW9uOiBcInJvd1wiLFxuICAgICAgZmxleFdyYXA6IFwibm93cmFwXCIsXG4gICAgICBhbGlnbkl0ZW1zOiBcImZsZXgtc3RhcnRcIixcbiAgICAgIGp1c3RpZnlDb250ZW50OiBcInNwYWNlLWJldHdlZW5cIixcbiAgICAgIC4uLnJvd0luZGV4IDwgcm93c0NvdW50IC0gMSA/IHsgbWFyZ2luQm90dG9tOiBgJHtsYXlvdXRPcHRpb25zLnNwYWNpbmd9cHhgIH0gOiBudWxsLFxuICAgICAgLi4uc3R5bGVcbiAgICB9LFxuICAgIC4uLnJlc3RSb3dDb250YWluZXJQcm9wc1xuICB9O1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCwgKHJlbmRlclJvd0NvbnRhaW5lciAhPSBudWxsID8gcmVuZGVyUm93Q29udGFpbmVyIDogZGVmYXVsdFJlbmRlclJvd0NvbnRhaW5lcikoe1xuICAgIGxheW91dE9wdGlvbnMsXG4gICAgcm93SW5kZXgsXG4gICAgcm93c0NvdW50LFxuICAgIHJvd0NvbnRhaW5lclByb3BzLFxuICAgIGNoaWxkcmVuXG4gIH0pKTtcbn1cbmZ1bmN0aW9uIFJvd3NMYXlvdXQocHJvcHMpIHtcbiAgY29uc3Qge1xuICAgIHBob3RvcyxcbiAgICBsYXlvdXRPcHRpb25zLFxuICAgIHJlbmRlclBob3RvLFxuICAgIHJlbmRlclJvd0NvbnRhaW5lcixcbiAgICBjb21wb25lbnRzUHJvcHM6IHsgaW1hZ2VQcm9wcywgcm93Q29udGFpbmVyUHJvcHMgfVxuICB9ID0gcHJvcHM7XG4gIGNvbnN0IHJvd3NMYXlvdXQgPSBjb21wdXRlUm93c0xheW91dCh7IHBob3RvcywgbGF5b3V0T3B0aW9ucyB9KTtcbiAgaWYgKCFyb3dzTGF5b3V0KSByZXR1cm4gbnVsbDtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsIHJvd3NMYXlvdXQubWFwKChyb3csIHJvd0luZGV4KSA9PiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgIFJvd0NvbnRhaW5lclJlbmRlcmVyLFxuICAgIHtcbiAgICAgIGtleTogYHJvdy0ke3Jvd0luZGV4fWAsXG4gICAgICBsYXlvdXRPcHRpb25zLFxuICAgICAgcm93SW5kZXgsXG4gICAgICByb3dzQ291bnQ6IHJvd3NMYXlvdXQubGVuZ3RoLFxuICAgICAgcmVuZGVyUm93Q29udGFpbmVyLFxuICAgICAgcm93Q29udGFpbmVyUHJvcHNcbiAgICB9LFxuICAgIHJvdy5tYXAoKHsgcGhvdG8sIGxheW91dCB9KSA9PiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgICAgUGhvdG9SZW5kZXJlcixcbiAgICAgIHtcbiAgICAgICAga2V5OiBwaG90by5rZXkgfHwgcGhvdG8uc3JjLFxuICAgICAgICBwaG90byxcbiAgICAgICAgbGF5b3V0LFxuICAgICAgICBsYXlvdXRPcHRpb25zLFxuICAgICAgICByZW5kZXJQaG90byxcbiAgICAgICAgaW1hZ2VQcm9wc1xuICAgICAgfVxuICAgICkpXG4gICkpKTtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVTaG9ydGVzdFBhdGgoZ3JhcGgsIHBhdGhMZW5ndGgsIHN0YXJ0Tm9kZSwgZW5kTm9kZSkge1xuICBjb25zdCBtYXRyaXggPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBjb25zdCBxdWV1ZSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIHF1ZXVlLmFkZChzdGFydE5vZGUpO1xuICBmb3IgKGxldCBsZW5ndGggPSAwOyBsZW5ndGggPCBwYXRoTGVuZ3RoOyBsZW5ndGggKz0gMSkge1xuICAgIGNvbnN0IGN1cnJlbnRRdWV1ZSA9IFsuLi5xdWV1ZS5rZXlzKCldO1xuICAgIHF1ZXVlLmNsZWFyKCk7XG4gICAgY3VycmVudFF1ZXVlLmZvckVhY2goKG5vZGUpID0+IHtcbiAgICAgIGNvbnN0IGFjY3VtdWxhdGVkV2VpZ2h0ID0gbGVuZ3RoID4gMCA/IG1hdHJpeC5nZXQobm9kZSlbbGVuZ3RoXS53ZWlnaHQgOiAwO1xuICAgICAgZ3JhcGgobm9kZSkuZm9yRWFjaCgoeyBuZWlnaGJvciwgd2VpZ2h0IH0pID0+IHtcbiAgICAgICAgbGV0IHBhdGhzID0gbWF0cml4LmdldChuZWlnaGJvcik7XG4gICAgICAgIGlmICghcGF0aHMpIHtcbiAgICAgICAgICBwYXRocyA9IFtdO1xuICAgICAgICAgIG1hdHJpeC5zZXQobmVpZ2hib3IsIHBhdGhzKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXdXZWlnaHQgPSBhY2N1bXVsYXRlZFdlaWdodCArIHdlaWdodDtcbiAgICAgICAgY29uc3QgbmV4dFBhdGggPSBwYXRoc1tsZW5ndGggKyAxXTtcbiAgICAgICAgaWYgKCFuZXh0UGF0aCB8fCBuZXh0UGF0aC53ZWlnaHQgPiBuZXdXZWlnaHQgJiYgKG5leHRQYXRoLndlaWdodCAvIG5ld1dlaWdodCA+IDEuMDAwMSB8fCBub2RlIDwgbmV4dFBhdGgubm9kZSkpIHtcbiAgICAgICAgICBwYXRoc1tsZW5ndGggKyAxXSA9IHsgbm9kZSwgd2VpZ2h0OiBuZXdXZWlnaHQgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGVuZ3RoIDwgcGF0aExlbmd0aCAtIDEgJiYgbmVpZ2hib3IgIT09IGVuZE5vZGUpIHtcbiAgICAgICAgICBxdWV1ZS5hZGQobmVpZ2hib3IpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gbWF0cml4O1xufVxuZnVuY3Rpb24gcmVjb25zdHJ1Y3RTaG9ydGVzdFBhdGgobWF0cml4LCBwYXRoTGVuZ3RoLCBlbmROb2RlKSB7XG4gIGNvbnN0IHBhdGggPSBbZW5kTm9kZV07XG4gIGZvciAobGV0IG5vZGUgPSBlbmROb2RlLCBsZW5ndGggPSBwYXRoTGVuZ3RoOyBsZW5ndGggPiAwOyBsZW5ndGggLT0gMSkge1xuICAgIG5vZGUgPSBtYXRyaXguZ2V0KG5vZGUpW2xlbmd0aF0ubm9kZTtcbiAgICBwYXRoLnB1c2gobm9kZSk7XG4gIH1cbiAgcmV0dXJuIHBhdGgucmV2ZXJzZSgpO1xufVxuZnVuY3Rpb24gZmluZFNob3J0ZXN0UGF0aExlbmd0aE4oZ3JhcGgsIHBhdGhMZW5ndGgsIHN0YXJ0Tm9kZSwgZW5kTm9kZSkge1xuICByZXR1cm4gcmVjb25zdHJ1Y3RTaG9ydGVzdFBhdGgoY29tcHV0ZVNob3J0ZXN0UGF0aChncmFwaCwgcGF0aExlbmd0aCwgc3RhcnROb2RlLCBlbmROb2RlKSwgcGF0aExlbmd0aCwgZW5kTm9kZSk7XG59XG5mdW5jdGlvbiBtYWtlR2V0Q29sdW1uTmVpZ2hib3JzKHtcbiAgcGhvdG9zLFxuICBzcGFjaW5nLFxuICBwYWRkaW5nLFxuICB0YXJnZXRDb2x1bW5XaWR0aCxcbiAgdGFyZ2V0Q29sdW1uSGVpZ2h0XG59KSB7XG4gIHJldHVybiAobm9kZSkgPT4ge1xuICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcbiAgICBjb25zdCBjdXRPZmZIZWlnaHQgPSB0YXJnZXRDb2x1bW5IZWlnaHQgKiAxLjU7XG4gICAgbGV0IGhlaWdodCA9IHRhcmdldENvbHVtbldpZHRoIC8gcmF0aW8ocGhvdG9zW25vZGVdKSArIDIgKiBwYWRkaW5nO1xuICAgIGZvciAobGV0IGkgPSBub2RlICsgMTsgaSA8IHBob3Rvcy5sZW5ndGggKyAxOyBpICs9IDEpIHtcbiAgICAgIHJlc3VsdHMucHVzaCh7IG5laWdoYm9yOiBpLCB3ZWlnaHQ6ICh0YXJnZXRDb2x1bW5IZWlnaHQgLSBoZWlnaHQpICoqIDIgfSk7XG4gICAgICBpZiAoaGVpZ2h0ID4gY3V0T2ZmSGVpZ2h0IHx8IGkgPT09IHBob3Rvcy5sZW5ndGgpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBoZWlnaHQgKz0gdGFyZ2V0Q29sdW1uV2lkdGggLyByYXRpbyhwaG90b3NbaV0pICsgc3BhY2luZyArIDIgKiBwYWRkaW5nO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfTtcbn1cbmZ1bmN0aW9uIGJ1aWxkQ29sdW1uc01vZGVsKHtcbiAgcGF0aCxcbiAgcGhvdG9zLFxuICBjb250YWluZXJXaWR0aCxcbiAgY29sdW1uc0dhcHMsXG4gIGNvbHVtbnNSYXRpb3MsXG4gIHNwYWNpbmcsXG4gIHBhZGRpbmdcbn0pIHtcbiAgY29uc3QgY29sdW1uc01vZGVsID0gW107XG4gIGNvbnN0IHRvdGFsUmF0aW8gPSBjb2x1bW5zUmF0aW9zLnJlZHVjZSgodG90YWwsIGNvbHVtblJhdGlvKSA9PiB0b3RhbCArIGNvbHVtblJhdGlvLCAwKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aCAtIDE7IGkgKz0gMSkge1xuICAgIGNvbnN0IGNvbHVtbiA9IHBob3Rvcy5tYXAoKHBob3RvLCBpbmRleCkgPT4gKHsgcGhvdG8sIGluZGV4IH0pKS5zbGljZShwYXRoW2ldLCBwYXRoW2kgKyAxXSk7XG4gICAgY29uc3QgdG90YWxBZGp1c3RlZEdhcHMgPSBjb2x1bW5zUmF0aW9zLnJlZHVjZShcbiAgICAgICh0b3RhbCwgY29sdW1uUmF0aW8sIGluZGV4KSA9PiB0b3RhbCArIChjb2x1bW5zR2Fwc1tpXSAtIGNvbHVtbnNHYXBzW2luZGV4XSkgKiBjb2x1bW5SYXRpbyxcbiAgICAgIDBcbiAgICApO1xuICAgIGNvbnN0IGNvbHVtbldpZHRoID0gKGNvbnRhaW5lcldpZHRoIC0gKHBhdGgubGVuZ3RoIC0gMikgKiBzcGFjaW5nIC0gMiAqIChwYXRoLmxlbmd0aCAtIDEpICogcGFkZGluZyAtIHRvdGFsQWRqdXN0ZWRHYXBzKSAqIGNvbHVtbnNSYXRpb3NbaV0gLyB0b3RhbFJhdGlvO1xuICAgIGNvbHVtbnNNb2RlbC5wdXNoKFxuICAgICAgY29sdW1uLm1hcCgoeyBwaG90bywgaW5kZXggfSwgcGhvdG9JbmRleCkgPT4gKHtcbiAgICAgICAgcGhvdG8sXG4gICAgICAgIGxheW91dDoge1xuICAgICAgICAgIHdpZHRoOiBjb2x1bW5XaWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IGNvbHVtbldpZHRoIC8gcmF0aW8ocGhvdG8pLFxuICAgICAgICAgIGluZGV4LFxuICAgICAgICAgIHBob3RvSW5kZXgsXG4gICAgICAgICAgcGhvdG9zQ291bnQ6IGNvbHVtbi5sZW5ndGhcbiAgICAgICAgfVxuICAgICAgfSkpXG4gICAgKTtcbiAgfVxuICByZXR1cm4gY29sdW1uc01vZGVsO1xufVxuZnVuY3Rpb24gY29tcHV0ZUNvbHVtbnNNb2RlbCh7XG4gIHBob3RvcyxcbiAgbGF5b3V0T3B0aW9ucyxcbiAgdGFyZ2V0Q29sdW1uV2lkdGhcbn0pIHtcbiAgY29uc3QgeyBjb2x1bW5zLCBzcGFjaW5nLCBwYWRkaW5nLCBjb250YWluZXJXaWR0aCB9ID0gbGF5b3V0T3B0aW9ucztcbiAgY29uc3QgY29sdW1uc0dhcHMgPSBbXTtcbiAgY29uc3QgY29sdW1uc1JhdGlvcyA9IFtdO1xuICBpZiAocGhvdG9zLmxlbmd0aCA8PSBjb2x1bW5zKSB7XG4gICAgY29uc3QgYXZlcmFnZVJhdGlvID0gcGhvdG9zLmxlbmd0aCA+IDAgPyBwaG90b3MucmVkdWNlKChhY2MsIHBob3RvKSA9PiBhY2MgKyByYXRpbyhwaG90byksIDApIC8gcGhvdG9zLmxlbmd0aCA6IDE7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb2x1bW5zOyBpICs9IDEpIHtcbiAgICAgIGNvbHVtbnNHYXBzW2ldID0gMiAqIHBhZGRpbmc7XG4gICAgICBjb2x1bW5zUmF0aW9zW2ldID0gaSA8IHBob3Rvcy5sZW5ndGggPyByYXRpbyhwaG90b3NbaV0pIDogYXZlcmFnZVJhdGlvO1xuICAgIH1cbiAgICBjb25zdCBjb2x1bW5zTW9kZWwyID0gYnVpbGRDb2x1bW5zTW9kZWwoe1xuICAgICAgcGF0aDogQXJyYXkuZnJvbSh7IGxlbmd0aDogY29sdW1ucyArIDEgfSkubWFwKChfLCBpbmRleCkgPT4gTWF0aC5taW4oaW5kZXgsIHBob3Rvcy5sZW5ndGgpKSxcbiAgICAgIHBob3RvcyxcbiAgICAgIGNvbHVtbnNSYXRpb3MsXG4gICAgICBjb2x1bW5zR2FwcyxcbiAgICAgIGNvbnRhaW5lcldpZHRoLFxuICAgICAgc3BhY2luZyxcbiAgICAgIHBhZGRpbmdcbiAgICB9KTtcbiAgICByZXR1cm4geyBjb2x1bW5zR2FwcywgY29sdW1uc1JhdGlvcywgY29sdW1uc01vZGVsOiBjb2x1bW5zTW9kZWwyIH07XG4gIH1cbiAgY29uc3QgdGFyZ2V0Q29sdW1uSGVpZ2h0ID0gKHBob3Rvcy5yZWR1Y2UoKGFjYywgcGhvdG8pID0+IGFjYyArIHRhcmdldENvbHVtbldpZHRoIC8gcmF0aW8ocGhvdG8pLCAwKSArIHNwYWNpbmcgKiAocGhvdG9zLmxlbmd0aCAtIGNvbHVtbnMpICsgMiAqIHBhZGRpbmcgKiBwaG90b3MubGVuZ3RoKSAvIGNvbHVtbnM7XG4gIGNvbnN0IGdldE5laWdoYm9ycyA9IG1ha2VHZXRDb2x1bW5OZWlnaGJvcnMoe1xuICAgIHBob3RvcyxcbiAgICB0YXJnZXRDb2x1bW5XaWR0aCxcbiAgICB0YXJnZXRDb2x1bW5IZWlnaHQsXG4gICAgc3BhY2luZyxcbiAgICBwYWRkaW5nXG4gIH0pO1xuICBjb25zdCBwYXRoID0gZmluZFNob3J0ZXN0UGF0aExlbmd0aE4oZ2V0TmVpZ2hib3JzLCBjb2x1bW5zLCAwLCBwaG90b3MubGVuZ3RoKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aCAtIDE7IGkgKz0gMSkge1xuICAgIGNvbnN0IGNvbHVtbiA9IHBob3Rvcy5zbGljZShwYXRoW2ldLCBwYXRoW2kgKyAxXSk7XG4gICAgY29sdW1uc0dhcHNbaV0gPSBzcGFjaW5nICogKGNvbHVtbi5sZW5ndGggLSAxKSArIDIgKiBwYWRkaW5nICogY29sdW1uLmxlbmd0aDtcbiAgICBjb2x1bW5zUmF0aW9zW2ldID0gMSAvIGNvbHVtbi5yZWR1Y2UoKGFjYywgcGhvdG8pID0+IGFjYyArIDEgLyByYXRpbyhwaG90byksIDApO1xuICB9XG4gIGNvbnN0IGNvbHVtbnNNb2RlbCA9IGJ1aWxkQ29sdW1uc01vZGVsKHtcbiAgICBwYXRoLFxuICAgIHBob3RvcyxcbiAgICBjb2x1bW5zUmF0aW9zLFxuICAgIGNvbHVtbnNHYXBzLFxuICAgIGNvbnRhaW5lcldpZHRoLFxuICAgIHNwYWNpbmcsXG4gICAgcGFkZGluZ1xuICB9KTtcbiAgcmV0dXJuIHsgY29sdW1uc0dhcHMsIGNvbHVtbnNSYXRpb3MsIGNvbHVtbnNNb2RlbCB9O1xufVxuZnVuY3Rpb24gY29tcHV0ZUxheW91dChwcm9wcykge1xuICBjb25zdCB7IHBob3RvcywgbGF5b3V0T3B0aW9ucyB9ID0gcHJvcHM7XG4gIGNvbnN0IHsgY29sdW1ucywgc3BhY2luZywgcGFkZGluZywgY29udGFpbmVyV2lkdGggfSA9IGxheW91dE9wdGlvbnM7XG4gIGNvbnN0IHRhcmdldENvbHVtbldpZHRoID0gKGNvbnRhaW5lcldpZHRoIC0gc3BhY2luZyAqIChjb2x1bW5zIC0gMSkgLSAyICogcGFkZGluZyAqIGNvbHVtbnMpIC8gY29sdW1ucztcbiAgY29uc3QgeyBjb2x1bW5zR2FwcywgY29sdW1uc1JhdGlvcywgY29sdW1uc01vZGVsIH0gPSBjb21wdXRlQ29sdW1uc01vZGVsKHtcbiAgICBwaG90b3MsXG4gICAgbGF5b3V0T3B0aW9ucyxcbiAgICB0YXJnZXRDb2x1bW5XaWR0aFxuICB9KTtcbiAgaWYgKGNvbHVtbnNNb2RlbC5maW5kSW5kZXgoXG4gICAgKGNvbHVtbk1vZGVsKSA9PiBjb2x1bW5Nb2RlbC5maW5kSW5kZXgoKHsgbGF5b3V0OiB7IHdpZHRoLCBoZWlnaHQgfSB9KSA9PiB3aWR0aCA8IDAgfHwgaGVpZ2h0IDwgMCkgPj0gMFxuICApID49IDApIHtcbiAgICBpZiAoY29sdW1ucyA+IDEpIHtcbiAgICAgIHJldHVybiBjb21wdXRlTGF5b3V0KHsgcGhvdG9zLCBsYXlvdXRPcHRpb25zOiB7IC4uLmxheW91dE9wdGlvbnMsIGNvbHVtbnM6IGNvbHVtbnMgLSAxIH0gfSk7XG4gICAgfVxuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgcmV0dXJuIHsgY29sdW1uc01vZGVsLCBjb2x1bW5zR2FwcywgY29sdW1uc1JhdGlvcyB9O1xufVxuZnVuY3Rpb24gY29tcHV0ZUNvbHVtbnNMYXlvdXQoe1xuICBwaG90b3MsXG4gIGxheW91dE9wdGlvbnNcbn0pIHtcbiAgcmV0dXJuIGNvbXB1dGVMYXlvdXQoeyBwaG90b3MsIGxheW91dE9wdGlvbnMgfSk7XG59XG5mdW5jdGlvbiBkZWZhdWx0UmVuZGVyQ29sdW1uQ29udGFpbmVyKHtcbiAgY29sdW1uQ29udGFpbmVyUHJvcHMsXG4gIGNoaWxkcmVuXG59KSB7XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgLi4uY29sdW1uQ29udGFpbmVyUHJvcHMgfSwgY2hpbGRyZW4pO1xufVxuZnVuY3Rpb24gY3NzQ29sdW1uV2lkdGgocHJvcHMpIHtcbiAgY29uc3QgeyBsYXlvdXRPcHRpb25zLCBjb2x1bW5JbmRleCwgY29sdW1uc0NvdW50LCBjb2x1bW5zR2FwcywgY29sdW1uc1JhdGlvcyB9ID0gcHJvcHM7XG4gIGNvbnN0IHsgbGF5b3V0LCBzcGFjaW5nLCBwYWRkaW5nIH0gPSBsYXlvdXRPcHRpb25zO1xuICBpZiAobGF5b3V0ID09PSBcIm1hc29ucnlcIiB8fCAhY29sdW1uc0dhcHMgfHwgIWNvbHVtbnNSYXRpb3MpIHtcbiAgICByZXR1cm4gYGNhbGMoKDEwMCUgLSAke3NwYWNpbmcgKiAoY29sdW1uc0NvdW50IC0gMSl9cHgpIC8gJHtjb2x1bW5zQ291bnR9KWA7XG4gIH1cbiAgY29uc3QgdG90YWxSYXRpbyA9IGNvbHVtbnNSYXRpb3MucmVkdWNlKChhY2MsIHJhdGlvMikgPT4gYWNjICsgcmF0aW8yLCAwKTtcbiAgY29uc3QgdG90YWxBZGp1c3RlZEdhcHMgPSBjb2x1bW5zUmF0aW9zLnJlZHVjZShcbiAgICAoYWNjLCByYXRpbzIsIGluZGV4KSA9PiBhY2MgKyAoY29sdW1uc0dhcHNbY29sdW1uSW5kZXhdIC0gY29sdW1uc0dhcHNbaW5kZXhdKSAqIHJhdGlvMixcbiAgICAwXG4gICk7XG4gIHJldHVybiBgY2FsYygoMTAwJSAtICR7cm91bmQoXG4gICAgKGNvbHVtbnNDb3VudCAtIDEpICogc3BhY2luZyArIDIgKiBjb2x1bW5zQ291bnQgKiBwYWRkaW5nICsgdG90YWxBZGp1c3RlZEdhcHMsXG4gICAgM1xuICApfXB4KSAqICR7cm91bmQoY29sdW1uc1JhdGlvc1tjb2x1bW5JbmRleF0gLyB0b3RhbFJhdGlvLCA1KX0gKyAkezIgKiBwYWRkaW5nfXB4KWA7XG59XG5mdW5jdGlvbiBDb2x1bW5Db250YWluZXJSZW5kZXJlcihwcm9wcykge1xuICBjb25zdCB7XG4gICAgbGF5b3V0T3B0aW9ucyxcbiAgICByZW5kZXJDb2x1bW5Db250YWluZXIsXG4gICAgY2hpbGRyZW4sXG4gICAgY29sdW1uQ29udGFpbmVyUHJvcHM6IHsgc3R5bGUsIGNsYXNzTmFtZSwgLi4ucmVzdENvbHVtbkNvbnRhaW5lclByb3BzIH0gPSB7fSxcbiAgICAuLi5yZXN0XG4gIH0gPSBwcm9wcztcbiAgY29uc3QgY29sdW1uQ29udGFpbmVyUHJvcHMgPSB7XG4gICAgY2xhc3NOYW1lOiBjbHN4KFwicmVhY3QtcGhvdG8tYWxidW0tLWNvbHVtblwiLCBjbGFzc05hbWUpLFxuICAgIHN0eWxlOiB7XG4gICAgICBkaXNwbGF5OiBcImZsZXhcIixcbiAgICAgIGZsZXhEaXJlY3Rpb246IFwiY29sdW1uXCIsXG4gICAgICBmbGV4V3JhcDogXCJub3dyYXBcIixcbiAgICAgIGFsaWduSXRlbXM6IFwiZmxleC1zdGFydFwiLFxuICAgICAgd2lkdGg6IGNzc0NvbHVtbldpZHRoKHByb3BzKSxcbiAgICAgIGp1c3RpZnlDb250ZW50OiBsYXlvdXRPcHRpb25zLmxheW91dCA9PT0gXCJjb2x1bW5zXCIgPyBcInNwYWNlLWJldHdlZW5cIiA6IFwiZmxleC1zdGFydFwiLFxuICAgICAgLi4uc3R5bGVcbiAgICB9LFxuICAgIC4uLnJlc3RDb2x1bW5Db250YWluZXJQcm9wc1xuICB9O1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCwgKHJlbmRlckNvbHVtbkNvbnRhaW5lciAhPSBudWxsID8gcmVuZGVyQ29sdW1uQ29udGFpbmVyIDogZGVmYXVsdFJlbmRlckNvbHVtbkNvbnRhaW5lcikoe1xuICAgIGxheW91dE9wdGlvbnMsXG4gICAgY29sdW1uQ29udGFpbmVyUHJvcHMsXG4gICAgY2hpbGRyZW4sXG4gICAgLi4ucmVzdFxuICB9KSk7XG59XG5mdW5jdGlvbiBDb2x1bW5zTGF5b3V0KHByb3BzKSB7XG4gIGNvbnN0IHtcbiAgICBwaG90b3MsXG4gICAgbGF5b3V0T3B0aW9ucyxcbiAgICByZW5kZXJQaG90byxcbiAgICByZW5kZXJDb2x1bW5Db250YWluZXIsXG4gICAgY29tcG9uZW50c1Byb3BzOiB7IGltYWdlUHJvcHMsIGNvbHVtbkNvbnRhaW5lclByb3BzIH1cbiAgfSA9IHByb3BzO1xuICBjb25zdCBjb2x1bW5zTGF5b3V0ID0gY29tcHV0ZUNvbHVtbnNMYXlvdXQoeyBwaG90b3MsIGxheW91dE9wdGlvbnMgfSk7XG4gIGlmICghY29sdW1uc0xheW91dCkgcmV0dXJuIG51bGw7XG4gIGNvbnN0IHsgY29sdW1uc01vZGVsLCBjb2x1bW5zUmF0aW9zLCBjb2x1bW5zR2FwcyB9ID0gY29sdW1uc0xheW91dDtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsIGNvbHVtbnNNb2RlbC5tYXAoKGNvbHVtbiwgY29sdW1uSW5kZXgpID0+IFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgQ29sdW1uQ29udGFpbmVyUmVuZGVyZXIsXG4gICAge1xuICAgICAga2V5OiBgY29sdW1uLSR7Y29sdW1uSW5kZXh9YCxcbiAgICAgIGxheW91dE9wdGlvbnMsXG4gICAgICBjb2x1bW5JbmRleCxcbiAgICAgIGNvbHVtbnNDb3VudDogY29sdW1uc01vZGVsLmxlbmd0aCxcbiAgICAgIGNvbHVtbnNHYXBzLFxuICAgICAgY29sdW1uc1JhdGlvcyxcbiAgICAgIHJlbmRlckNvbHVtbkNvbnRhaW5lcixcbiAgICAgIGNvbHVtbkNvbnRhaW5lclByb3BzXG4gICAgfSxcbiAgICBjb2x1bW4ubWFwKCh7IHBob3RvLCBsYXlvdXQgfSkgPT4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgIFBob3RvUmVuZGVyZXIsXG4gICAgICB7XG4gICAgICAgIGtleTogcGhvdG8ua2V5IHx8IHBob3RvLnNyYyxcbiAgICAgICAgcGhvdG8sXG4gICAgICAgIGxheW91dCxcbiAgICAgICAgbGF5b3V0T3B0aW9ucyxcbiAgICAgICAgcmVuZGVyUGhvdG8sXG4gICAgICAgIGltYWdlUHJvcHNcbiAgICAgIH1cbiAgICApKVxuICApKSk7XG59XG5mdW5jdGlvbiBjb21wdXRlTWFzb25yeUxheW91dChwcm9wcykge1xuICBjb25zdCB7IHBob3RvcywgbGF5b3V0T3B0aW9ucyB9ID0gcHJvcHM7XG4gIGNvbnN0IHsgY29sdW1ucywgc3BhY2luZywgcGFkZGluZywgY29udGFpbmVyV2lkdGggfSA9IGxheW91dE9wdGlvbnM7XG4gIGNvbnN0IGNvbHVtbldpZHRoID0gKGNvbnRhaW5lcldpZHRoIC0gc3BhY2luZyAqIChjb2x1bW5zIC0gMSkgLSAyICogcGFkZGluZyAqIGNvbHVtbnMpIC8gY29sdW1ucztcbiAgaWYgKGNvbHVtbldpZHRoIDw9IDApIHtcbiAgICByZXR1cm4gY29sdW1ucyA+IDEgPyBjb21wdXRlTWFzb25yeUxheW91dCh7XG4gICAgICAuLi5wcm9wcyxcbiAgICAgIGxheW91dE9wdGlvbnM6IHsgLi4ubGF5b3V0T3B0aW9ucywgY29sdW1uczogY29sdW1ucyAtIDEgfVxuICAgIH0pIDogdm9pZCAwO1xuICB9XG4gIGNvbnN0IGNvbHVtbnNDdXJyZW50VG9wUG9zaXRpb25zID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY29sdW1uczsgaSArPSAxKSB7XG4gICAgY29sdW1uc0N1cnJlbnRUb3BQb3NpdGlvbnNbaV0gPSAwO1xuICB9XG4gIGNvbnN0IGNvbHVtbnNNb2RlbCA9IHBob3Rvcy5yZWR1Y2UoXG4gICAgKG1vZGVsLCBwaG90bywgaW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IHNob3J0ZXN0Q29sdW1uID0gY29sdW1uc0N1cnJlbnRUb3BQb3NpdGlvbnMucmVkdWNlKFxuICAgICAgICAoY3VycmVudFNob3J0ZXN0Q29sdW1uLCBpdGVtLCBpKSA9PiBpdGVtIDwgY29sdW1uc0N1cnJlbnRUb3BQb3NpdGlvbnNbY3VycmVudFNob3J0ZXN0Q29sdW1uXSAtIDEgPyBpIDogY3VycmVudFNob3J0ZXN0Q29sdW1uLFxuICAgICAgICAwXG4gICAgICApO1xuICAgICAgY29sdW1uc0N1cnJlbnRUb3BQb3NpdGlvbnNbc2hvcnRlc3RDb2x1bW5dID0gY29sdW1uc0N1cnJlbnRUb3BQb3NpdGlvbnNbc2hvcnRlc3RDb2x1bW5dICsgY29sdW1uV2lkdGggLyByYXRpbyhwaG90bykgKyBzcGFjaW5nICsgMiAqIHBhZGRpbmc7XG4gICAgICBtb2RlbFtzaG9ydGVzdENvbHVtbl0ucHVzaCh7IHBob3RvLCBpbmRleCB9KTtcbiAgICAgIHJldHVybiBtb2RlbDtcbiAgICB9LFxuICAgIEFycmF5LmZyb20oeyBsZW5ndGg6IGNvbHVtbnMgfSkubWFwKCgpID0+IFtdKVxuICApO1xuICByZXR1cm4gY29sdW1uc01vZGVsLm1hcChcbiAgICAoY29sdW1uKSA9PiBjb2x1bW4ubWFwKCh7IHBob3RvLCBpbmRleCB9LCBwaG90b0luZGV4KSA9PiAoe1xuICAgICAgcGhvdG8sXG4gICAgICBsYXlvdXQ6IHtcbiAgICAgICAgd2lkdGg6IGNvbHVtbldpZHRoLFxuICAgICAgICBoZWlnaHQ6IGNvbHVtbldpZHRoIC8gcmF0aW8ocGhvdG8pLFxuICAgICAgICBpbmRleCxcbiAgICAgICAgcGhvdG9JbmRleCxcbiAgICAgICAgcGhvdG9zQ291bnQ6IGNvbHVtbi5sZW5ndGhcbiAgICAgIH1cbiAgICB9KSlcbiAgKTtcbn1cbmZ1bmN0aW9uIE1hc29ucnlMYXlvdXQocHJvcHMpIHtcbiAgY29uc3Qge1xuICAgIHBob3RvcyxcbiAgICBsYXlvdXRPcHRpb25zLFxuICAgIHJlbmRlclBob3RvLFxuICAgIHJlbmRlckNvbHVtbkNvbnRhaW5lcixcbiAgICBjb21wb25lbnRzUHJvcHM6IHsgaW1hZ2VQcm9wcywgY29sdW1uQ29udGFpbmVyUHJvcHMgfVxuICB9ID0gcHJvcHM7XG4gIGNvbnN0IG1hc29ucnlMYXlvdXQgPSBjb21wdXRlTWFzb25yeUxheW91dCh7IHBob3RvcywgbGF5b3V0T3B0aW9ucyB9KTtcbiAgaWYgKCFtYXNvbnJ5TGF5b3V0KSByZXR1cm4gbnVsbDtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsIG1hc29ucnlMYXlvdXQubWFwKChjb2x1bW4sIGNvbHVtbkluZGV4KSA9PiBSZWFjdC5jcmVhdGVFbGVtZW50KFxuICAgIENvbHVtbkNvbnRhaW5lclJlbmRlcmVyLFxuICAgIHtcbiAgICAgIGtleTogYG1hc29ucnktY29sdW1uLSR7Y29sdW1uSW5kZXh9YCxcbiAgICAgIGxheW91dE9wdGlvbnMsXG4gICAgICBjb2x1bW5zQ291bnQ6IG1hc29ucnlMYXlvdXQubGVuZ3RoLFxuICAgICAgY29sdW1uSW5kZXgsXG4gICAgICByZW5kZXJDb2x1bW5Db250YWluZXIsXG4gICAgICBjb2x1bW5Db250YWluZXJQcm9wc1xuICAgIH0sXG4gICAgY29sdW1uLm1hcCgoeyBwaG90bywgbGF5b3V0IH0pID0+IFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICBQaG90b1JlbmRlcmVyLFxuICAgICAge1xuICAgICAgICBrZXk6IHBob3RvLmtleSB8fCBwaG90by5zcmMsXG4gICAgICAgIHBob3RvLFxuICAgICAgICBsYXlvdXQsXG4gICAgICAgIGxheW91dE9wdGlvbnMsXG4gICAgICAgIHJlbmRlclBob3RvLFxuICAgICAgICBpbWFnZVByb3BzXG4gICAgICB9XG4gICAgKSlcbiAgKSkpO1xufVxuZnVuY3Rpb24gZGVmYXVsdFJlbmRlckNvbnRhaW5lcih7IGNvbnRhaW5lclByb3BzLCBjaGlsZHJlbiwgY29udGFpbmVyUmVmIH0pIHtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyByZWY6IGNvbnRhaW5lclJlZiwgLi4uY29udGFpbmVyUHJvcHMgfSwgY2hpbGRyZW4pO1xufVxuZnVuY3Rpb24gQ29udGFpbmVyUmVuZGVyZXIocHJvcHMpIHtcbiAgY29uc3Qge1xuICAgIGxheW91dCxcbiAgICByZW5kZXJDb250YWluZXIsXG4gICAgY2hpbGRyZW4sXG4gICAgY29udGFpbmVyUmVmLFxuICAgIGNvbnRhaW5lclByb3BzOiB7IHN0eWxlLCBjbGFzc05hbWUsIC4uLnJlc3RDb250YWluZXJQcm9wcyB9ID0ge31cbiAgfSA9IHByb3BzO1xuICBjb25zdCBjb250YWluZXJQcm9wcyA9IHtcbiAgICBjbGFzc05hbWU6IGNsc3goXCJyZWFjdC1waG90by1hbGJ1bVwiLCBgcmVhY3QtcGhvdG8tYWxidW0tLSR7bGF5b3V0fWAsIGNsYXNzTmFtZSksXG4gICAgc3R5bGU6IHtcbiAgICAgIGRpc3BsYXk6IFwiZmxleFwiLFxuICAgICAgZmxleFdyYXA6IFwibm93cmFwXCIsXG4gICAgICBqdXN0aWZ5Q29udGVudDogXCJzcGFjZS1iZXR3ZWVuXCIsXG4gICAgICBmbGV4RGlyZWN0aW9uOiBsYXlvdXQgPT09IFwicm93c1wiID8gXCJjb2x1bW5cIiA6IFwicm93XCIsXG4gICAgICAuLi5zdHlsZVxuICAgIH0sXG4gICAgLi4ucmVzdENvbnRhaW5lclByb3BzXG4gIH07XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLCAocmVuZGVyQ29udGFpbmVyICE9IG51bGwgPyByZW5kZXJDb250YWluZXIgOiBkZWZhdWx0UmVuZGVyQ29udGFpbmVyKSh7XG4gICAgY29udGFpbmVyUHJvcHMsXG4gICAgY29udGFpbmVyUmVmLFxuICAgIGxheW91dCxcbiAgICBjaGlsZHJlblxuICB9KSk7XG59XG5mdW5jdGlvbiB1c2VBcnJheShhcnJheSkge1xuICBjb25zdCByZWYgPSBSZWFjdC51c2VSZWYoYXJyYXkpO1xuICBpZiAoIWFycmF5IHx8ICFyZWYuY3VycmVudCB8fCBhcnJheS5qb2luKCkgIT09IHJlZi5jdXJyZW50LmpvaW4oKSkge1xuICAgIHJlZi5jdXJyZW50ID0gYXJyYXk7XG4gIH1cbiAgcmV0dXJuIHJlZi5jdXJyZW50O1xufVxuZnVuY3Rpb24gY29udGFpbmVyV2lkdGhSZWR1Y2VyKHN0YXRlLCB7IG5ld0NvbnRhaW5lcldpZHRoLCBuZXdTY3JvbGxiYXJXaWR0aCB9KSB7XG4gIGNvbnN0IHsgY29udGFpbmVyV2lkdGgsIHNjcm9sbGJhcldpZHRoIH0gPSBzdGF0ZTtcbiAgaWYgKGNvbnRhaW5lcldpZHRoICE9PSB2b2lkIDAgJiYgc2Nyb2xsYmFyV2lkdGggIT09IHZvaWQgMCAmJiBuZXdDb250YWluZXJXaWR0aCAhPT0gdm9pZCAwICYmIG5ld1Njcm9sbGJhcldpZHRoICE9PSB2b2lkIDAgJiYgbmV3Q29udGFpbmVyV2lkdGggPiBjb250YWluZXJXaWR0aCAmJiBuZXdDb250YWluZXJXaWR0aCAtIGNvbnRhaW5lcldpZHRoIDw9IDIwICYmIG5ld1Njcm9sbGJhcldpZHRoIDwgc2Nyb2xsYmFyV2lkdGgpIHtcbiAgICByZXR1cm4geyBjb250YWluZXJXaWR0aCwgc2Nyb2xsYmFyV2lkdGg6IG5ld1Njcm9sbGJhcldpZHRoIH07XG4gIH1cbiAgcmV0dXJuIGNvbnRhaW5lcldpZHRoICE9PSBuZXdDb250YWluZXJXaWR0aCB8fCBzY3JvbGxiYXJXaWR0aCAhPT0gbmV3U2Nyb2xsYmFyV2lkdGggPyB7IGNvbnRhaW5lcldpZHRoOiBuZXdDb250YWluZXJXaWR0aCwgc2Nyb2xsYmFyV2lkdGg6IG5ld1Njcm9sbGJhcldpZHRoIH0gOiBzdGF0ZTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVDb250YWluZXJXaWR0aChlbCwgYnJlYWtwb2ludHMyKSB7XG4gIGxldCB3aWR0aCA9IGVsID09IG51bGwgPyB2b2lkIDAgOiBlbC5jbGllbnRXaWR0aDtcbiAgaWYgKHdpZHRoICE9PSB2b2lkIDAgJiYgYnJlYWtwb2ludHMyICYmIGJyZWFrcG9pbnRzMi5sZW5ndGggPiAwKSB7XG4gICAgY29uc3Qgc29ydGVkID0gWy4uLmJyZWFrcG9pbnRzMi5maWx0ZXIoKHgpID0+IHggPiAwKV0uc29ydCgoYSwgYikgPT4gYiAtIGEpO1xuICAgIHNvcnRlZC5wdXNoKE1hdGguZmxvb3Ioc29ydGVkW3NvcnRlZC5sZW5ndGggLSAxXSAvIDIpKTtcbiAgICBjb25zdCB0aHJlc2hvbGQgPSB3aWR0aDtcbiAgICB3aWR0aCA9IHNvcnRlZC5maW5kKChicmVha3BvaW50LCBpbmRleCkgPT4gYnJlYWtwb2ludCA8PSB0aHJlc2hvbGQgfHwgaW5kZXggPT09IHNvcnRlZC5sZW5ndGggLSAxKTtcbiAgfVxuICByZXR1cm4gd2lkdGg7XG59XG5mdW5jdGlvbiB1c2VDb250YWluZXJXaWR0aChicmVha3BvaW50czIsIGRlZmF1bHRDb250YWluZXJXaWR0aCkge1xuICBjb25zdCBbeyBjb250YWluZXJXaWR0aCB9LCBkaXNwYXRjaF0gPSBSZWFjdC51c2VSZWR1Y2VyKGNvbnRhaW5lcldpZHRoUmVkdWNlciwge1xuICAgIGNvbnRhaW5lcldpZHRoOiBkZWZhdWx0Q29udGFpbmVyV2lkdGhcbiAgfSk7XG4gIGNvbnN0IHJlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgY29uc3Qgb2JzZXJ2ZXJSZWYgPSBSZWFjdC51c2VSZWYoKTtcbiAgY29uc3QgY29udGFpbmVyUmVmID0gUmVhY3QudXNlQ2FsbGJhY2soXG4gICAgKG5vZGUpID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIChfYSA9IG9ic2VydmVyUmVmLmN1cnJlbnQpID09IG51bGwgPyB2b2lkIDAgOiBfYS5kaXNjb25uZWN0KCk7XG4gICAgICBvYnNlcnZlclJlZi5jdXJyZW50ID0gdm9pZCAwO1xuICAgICAgcmVmLmN1cnJlbnQgPSBub2RlO1xuICAgICAgY29uc3QgdXBkYXRlV2lkdGggPSAoKSA9PiBkaXNwYXRjaCh7XG4gICAgICAgIG5ld0NvbnRhaW5lcldpZHRoOiByZXNvbHZlQ29udGFpbmVyV2lkdGgocmVmLmN1cnJlbnQsIGJyZWFrcG9pbnRzMiksXG4gICAgICAgIG5ld1Njcm9sbGJhcldpZHRoOiB3aW5kb3cuaW5uZXJXaWR0aCAtIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aFxuICAgICAgfSk7XG4gICAgICB1cGRhdGVXaWR0aCgpO1xuICAgICAgaWYgKG5vZGUgJiYgdHlwZW9mIFJlc2l6ZU9ic2VydmVyICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIG9ic2VydmVyUmVmLmN1cnJlbnQgPSBuZXcgUmVzaXplT2JzZXJ2ZXIodXBkYXRlV2lkdGgpO1xuICAgICAgICBvYnNlcnZlclJlZi5jdXJyZW50Lm9ic2VydmUobm9kZSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBbYnJlYWtwb2ludHMyXVxuICApO1xuICByZXR1cm4geyBjb250YWluZXJSZWYsIGNvbnRhaW5lcldpZHRoIH07XG59XG5jb25zdCBicmVha3BvaW50cyA9IE9iamVjdC5mcmVlemUoWzEyMDAsIDYwMCwgMzAwLCAwXSk7XG5mdW5jdGlvbiB1bndyYXAodmFsdWUsIGFyZykge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIgPyB2YWx1ZShhcmcpIDogdmFsdWU7XG59XG5mdW5jdGlvbiB1bndyYXBQYXJhbWV0ZXIodmFsdWUsIGNvbnRhaW5lcldpZHRoKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgIT09IFwidW5kZWZpbmVkXCIgPyB1bndyYXAodmFsdWUsIGNvbnRhaW5lcldpZHRoKSA6IHZvaWQgMDtcbn1cbmZ1bmN0aW9uIHNlbGVjdFJlc3BvbnNpdmVWYWx1ZSh2YWx1ZXMsIGNvbnRhaW5lcldpZHRoKSB7XG4gIGNvbnN0IGluZGV4ID0gYnJlYWtwb2ludHMuZmluZEluZGV4KChicmVha3BvaW50KSA9PiBicmVha3BvaW50IDw9IGNvbnRhaW5lcldpZHRoKTtcbiAgcmV0dXJuIHVud3JhcCh2YWx1ZXNbaW5kZXggPj0gMCA/IGluZGV4IDogMF0sIGNvbnRhaW5lcldpZHRoKTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVSZXNwb25zaXZlUGFyYW1ldGVyKHBhcmFtZXRlciwgY29udGFpbmVyV2lkdGgsIHZhbHVlcywgbWluVmFsdWUgPSAwKSB7XG4gIGNvbnN0IHZhbHVlID0gdW53cmFwUGFyYW1ldGVyKHBhcmFtZXRlciwgY29udGFpbmVyV2lkdGgpO1xuICByZXR1cm4gTWF0aC5yb3VuZChNYXRoLm1heCh2YWx1ZSA9PT0gdm9pZCAwID8gc2VsZWN0UmVzcG9uc2l2ZVZhbHVlKHZhbHVlcywgY29udGFpbmVyV2lkdGgpIDogdmFsdWUsIG1pblZhbHVlKSk7XG59XG5mdW5jdGlvbiByZXNvbHZlTGF5b3V0T3B0aW9ucyh7XG4gIGxheW91dCxcbiAgb25DbGljayxcbiAgY29udGFpbmVyV2lkdGgsXG4gIHRhcmdldFJvd0hlaWdodCxcbiAgcm93Q29uc3RyYWludHMsXG4gIGNvbHVtbnMsXG4gIHNwYWNpbmcsXG4gIHBhZGRpbmcsXG4gIHNpemVzXG59KSB7XG4gIHJldHVybiB7XG4gICAgbGF5b3V0LFxuICAgIG9uQ2xpY2ssXG4gICAgY29udGFpbmVyV2lkdGgsXG4gICAgY29sdW1uczogcmVzb2x2ZVJlc3BvbnNpdmVQYXJhbWV0ZXIoY29sdW1ucywgY29udGFpbmVyV2lkdGgsIFs1LCA0LCAzLCAyXSwgMSksXG4gICAgc3BhY2luZzogcmVzb2x2ZVJlc3BvbnNpdmVQYXJhbWV0ZXIoc3BhY2luZywgY29udGFpbmVyV2lkdGgsIFsyMCwgMTUsIDEwLCA1XSksXG4gICAgcGFkZGluZzogcmVzb2x2ZVJlc3BvbnNpdmVQYXJhbWV0ZXIocGFkZGluZywgY29udGFpbmVyV2lkdGgsIFswLCAwLCAwLCAwLCAwXSksXG4gICAgdGFyZ2V0Um93SGVpZ2h0OiByZXNvbHZlUmVzcG9uc2l2ZVBhcmFtZXRlcih0YXJnZXRSb3dIZWlnaHQsIGNvbnRhaW5lcldpZHRoLCBbXG4gICAgICAodykgPT4gdyAvIDUsXG4gICAgICAodykgPT4gdyAvIDQsXG4gICAgICAodykgPT4gdyAvIDMsXG4gICAgICAodykgPT4gdyAvIDJcbiAgICBdKSxcbiAgICByb3dDb25zdHJhaW50czogdW53cmFwUGFyYW1ldGVyKHJvd0NvbnN0cmFpbnRzLCBjb250YWluZXJXaWR0aCksXG4gICAgc2l6ZXNcbiAgfTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVDb21wb25lbnRzUHJvcHMocHJvcHMsIGNvbnRhaW5lcldpZHRoLCBsYXlvdXRPcHRpb25zKSB7XG4gIGNvbnN0IHsgcGhvdG9zLCBjb21wb25lbnRzUHJvcHM6IGNvbXBvbmVudHNQcm9wc1Byb3AgfSA9IHByb3BzO1xuICBjb25zdCBjb21wb25lbnRzUHJvcHMgPSB1bndyYXAoY29tcG9uZW50c1Byb3BzUHJvcCwgY29udGFpbmVyV2lkdGgpIHx8IHt9O1xuICBpZiAobGF5b3V0T3B0aW9ucykge1xuICAgIGNvbnN0IHsgbGF5b3V0LCBzcGFjaW5nLCBwYWRkaW5nLCByb3dDb25zdHJhaW50cyB9ID0gbGF5b3V0T3B0aW9ucztcbiAgICBpZiAobGF5b3V0ID09PSBcInJvd3NcIikge1xuICAgICAgY29uc3QgeyBzaW5nbGVSb3dNYXhIZWlnaHQgfSA9IHJvd0NvbnN0cmFpbnRzIHx8IHt9O1xuICAgICAgaWYgKHNpbmdsZVJvd01heEhlaWdodCkge1xuICAgICAgICBjb25zdCBtYXhXaWR0aCA9IE1hdGguZmxvb3IoXG4gICAgICAgICAgcGhvdG9zLnJlZHVjZShcbiAgICAgICAgICAgIChhY2MsIHsgd2lkdGgsIGhlaWdodCB9KSA9PiBhY2MgKyB3aWR0aCAvIGhlaWdodCAqIHNpbmdsZVJvd01heEhlaWdodCAtIDIgKiBwYWRkaW5nLFxuICAgICAgICAgICAgcGFkZGluZyAqIHBob3Rvcy5sZW5ndGggKiAyICsgc3BhY2luZyAqIChwaG90b3MubGVuZ3RoIC0gMSlcbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICAgIGlmIChtYXhXaWR0aCA+IDApIHtcbiAgICAgICAgICBjb21wb25lbnRzUHJvcHMuY29udGFpbmVyUHJvcHMgPSBjb21wb25lbnRzUHJvcHMuY29udGFpbmVyUHJvcHMgfHwge307XG4gICAgICAgICAgY29tcG9uZW50c1Byb3BzLmNvbnRhaW5lclByb3BzLnN0eWxlID0geyBtYXhXaWR0aCwgLi4uY29tcG9uZW50c1Byb3BzLmNvbnRhaW5lclByb3BzLnN0eWxlIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNvbXBvbmVudHNQcm9wcztcbn1cbmZ1bmN0aW9uIHJlbmRlckxheW91dChwcm9wcywgY29tcG9uZW50c1Byb3BzLCBsYXlvdXRPcHRpb25zKSB7XG4gIGNvbnN0IHsgcGhvdG9zLCBsYXlvdXQsIHJlbmRlclBob3RvLCByZW5kZXJSb3dDb250YWluZXIsIHJlbmRlckNvbHVtbkNvbnRhaW5lciB9ID0gcHJvcHM7XG4gIGNvbnN0IGNvbW1vbkxheW91dFByb3BzID0geyBwaG90b3MsIHJlbmRlclBob3RvLCBjb21wb25lbnRzUHJvcHMgfTtcbiAgaWYgKGxheW91dCA9PT0gXCJyb3dzXCIpIHtcbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICAgIFJvd3NMYXlvdXQsXG4gICAgICB7XG4gICAgICAgIGxheW91dE9wdGlvbnMsXG4gICAgICAgIHJlbmRlclJvd0NvbnRhaW5lcixcbiAgICAgICAgLi4uY29tbW9uTGF5b3V0UHJvcHNcbiAgICAgIH1cbiAgICApO1xuICB9XG4gIGlmIChsYXlvdXQgPT09IFwiY29sdW1uc1wiKSB7XG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgICBDb2x1bW5zTGF5b3V0LFxuICAgICAge1xuICAgICAgICBsYXlvdXRPcHRpb25zLFxuICAgICAgICByZW5kZXJDb2x1bW5Db250YWluZXIsXG4gICAgICAgIC4uLmNvbW1vbkxheW91dFByb3BzXG4gICAgICB9XG4gICAgKTtcbiAgfVxuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcbiAgICBNYXNvbnJ5TGF5b3V0LFxuICAgIHtcbiAgICAgIGxheW91dE9wdGlvbnMsXG4gICAgICByZW5kZXJDb2x1bW5Db250YWluZXIsXG4gICAgICAuLi5jb21tb25MYXlvdXRQcm9wc1xuICAgIH1cbiAgKTtcbn1cbmZ1bmN0aW9uIFBob3RvQWxidW0ocHJvcHMpIHtcbiAgY29uc3QgeyBwaG90b3MsIGxheW91dCwgcmVuZGVyQ29udGFpbmVyLCBkZWZhdWx0Q29udGFpbmVyV2lkdGgsIGJyZWFrcG9pbnRzOiBicmVha3BvaW50czIgfSA9IHByb3BzO1xuICBjb25zdCB7IGNvbnRhaW5lclJlZiwgY29udGFpbmVyV2lkdGggfSA9IHVzZUNvbnRhaW5lcldpZHRoKHVzZUFycmF5KGJyZWFrcG9pbnRzMiksIGRlZmF1bHRDb250YWluZXJXaWR0aCk7XG4gIGlmICghbGF5b3V0IHx8ICFbXCJyb3dzXCIsIFwiY29sdW1uc1wiLCBcIm1hc29ucnlcIl0uaW5jbHVkZXMobGF5b3V0KSB8fCAhQXJyYXkuaXNBcnJheShwaG90b3MpKSByZXR1cm4gbnVsbDtcbiAgY29uc3QgbGF5b3V0T3B0aW9ucyA9IGNvbnRhaW5lcldpZHRoID8gcmVzb2x2ZUxheW91dE9wdGlvbnMoeyBjb250YWluZXJXaWR0aCwgLi4ucHJvcHMgfSkgOiB2b2lkIDA7XG4gIGNvbnN0IGNvbXBvbmVudHNQcm9wcyA9IHJlc29sdmVDb21wb25lbnRzUHJvcHMocHJvcHMsIGNvbnRhaW5lcldpZHRoLCBsYXlvdXRPcHRpb25zKTtcbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXG4gICAgQ29udGFpbmVyUmVuZGVyZXIsXG4gICAge1xuICAgICAgbGF5b3V0LFxuICAgICAgY29udGFpbmVyUmVmLFxuICAgICAgcmVuZGVyQ29udGFpbmVyLFxuICAgICAgY29udGFpbmVyUHJvcHM6IGNvbXBvbmVudHNQcm9wcy5jb250YWluZXJQcm9wc1xuICAgIH0sXG4gICAgbGF5b3V0T3B0aW9ucyAmJiByZW5kZXJMYXlvdXQocHJvcHMsIGNvbXBvbmVudHNQcm9wcywgbGF5b3V0T3B0aW9ucylcbiAgKTtcbn1cbmV4cG9ydCB7XG4gIFBob3RvQWxidW0sXG4gIFBob3RvQWxidW0gYXMgZGVmYXVsdCxcbiAgY29tcHV0ZUNvbHVtbnNMYXlvdXQgYXMgdW5zdGFibGVfY29tcHV0ZUNvbHVtbnNMYXlvdXQsXG4gIGNvbXB1dGVNYXNvbnJ5TGF5b3V0IGFzIHVuc3RhYmxlX2NvbXB1dGVNYXNvbnJ5TGF5b3V0LFxuICBjb21wdXRlUm93c0xheW91dCBhcyB1bnN0YWJsZV9jb21wdXRlUm93c0xheW91dFxufTtcbiJdLCJuYW1lcyI6WyJSZWFjdCIsInJhdGlvIiwid2lkdGgiLCJoZWlnaHQiLCJyb3VuZCIsInZhbHVlIiwiZGVjaW1hbHMiLCJmYWN0b3IiLCJNYXRoIiwiTnVtYmVyIiwiRVBTSUxPTiIsInJhbmtpbmdGdW5jdGlvbkNvbXBhcmF0b3IiLCJyYW5rIiwiYSIsImIiLCJNaW5IZWFwIiwiY29uc3RydWN0b3IiLCJjb21wYXJhdG9yIiwiaGVhcCIsIm4iLCJncmVhdGVyIiwiaSIsImoiLCJzd2FwIiwidGVtcCIsInN3aW0iLCJrIiwiazIiLCJmbG9vciIsInNpbmsiLCJwdXNoIiwiZWxlbWVudCIsInBvcCIsIm1heCIsInNpemUiLCJidWlsZFByZWNlZGVudHNNYXAiLCJncmFwaCIsInN0YXJ0Tm9kZSIsImVuZE5vZGUiLCJwcmVjZWRlbnRzTWFwIiwiTWFwIiwidmlzaXRlZCIsIlNldCIsInN0b3JlZFNob3J0ZXN0UGF0aHMiLCJzZXQiLCJxdWV1ZSIsImVsIiwid2VpZ2h0IiwiaWQiLCJoYXMiLCJuZWlnaGJvcmluZ05vZGVzIiwiYWRkIiwiZm9yRWFjaCIsIm5laWdoYm9yV2VpZ2h0IiwibmVpZ2hib3IiLCJuZXdXZWlnaHQiLCJjdXJyZW50SWQiLCJnZXQiLCJjdXJyZW50V2VpZ2h0IiwiZ2V0UGF0aEZyb21QcmVjZWRlbnRzTWFwIiwibm9kZXMiLCJub2RlIiwicmV2ZXJzZSIsImZpbmRTaG9ydGVzdFBhdGgiLCJmaW5kSWRlYWxOb2RlU2VhcmNoIiwicGhvdG9zIiwidGFyZ2V0Um93SGVpZ2h0IiwiY29udGFpbmVyV2lkdGgiLCJtaW5SYXRpbyIsInJlZHVjZSIsImFjYyIsInBob3RvIiwibWluIiwiTUFYX1ZBTFVFIiwiZ2V0Q29tbW9uSGVpZ2h0Iiwicm93Iiwic3BhY2luZyIsInBhZGRpbmciLCJyb3dXaWR0aCIsImxlbmd0aCIsInRvdGFsQXNwZWN0UmF0aW8iLCJjb3N0Iiwic2xpY2UiLCJjb21tb25IZWlnaHQiLCJtYWtlR2V0Um93TmVpZ2hib3JzIiwibGF5b3V0T3B0aW9ucyIsImxpbWl0Tm9kZVNlYXJjaCIsInJvd0NvbnN0cmFpbnRzIiwiX2EiLCJfYiIsInJlc3VsdHMiLCJzdGFydE9mZnNldCIsIm1pblBob3RvcyIsImVuZE9mZnNldCIsIm1heFBob3RvcyIsIkluZmluaXR5IiwiY3VycmVudENvc3QiLCJjb21wdXRlUm93c0xheW91dCIsImdldE5laWdoYm9ycyIsInBhdGgiLCJsYXlvdXQiLCJtYXAiLCJpbmRleCIsInBob3RvSW5kZXgiLCJwaG90b3NDb3VudCIsImNsc3giLCJjbGFzc2VzIiwiZmlsdGVyIiwiY2xzIiwiQm9vbGVhbiIsImpvaW4iLCJjYWxjV2lkdGgiLCJiYXNlIiwicGhvdG9MYXlvdXQiLCJjb3VudCIsImNvbHVtbnMiLCJnYXBzIiwiY3NzUGhvdG9XaWR0aCIsImNhbGN1bGF0ZVNpemVzVmFsdWUiLCJtYXRjaCIsInNyY1NldEFuZFNpemVzIiwic3JjU2V0Iiwic2l6ZXMiLCJpbWFnZXMiLCJjb25jYXQiLCJmaW5kIiwic3JjIiwic29ydCIsImZpcnN0Iiwic2Vjb25kIiwiaW1hZ2UiLCJ2aWV3cG9ydCIsImNlaWwiLCJQaG90b1JlbmRlcmVyIiwicHJvcHMiLCJpbWFnZVByb3BzIiwic3R5bGUiLCJjbGFzc05hbWUiLCJyZXN0SW1hZ2VQcm9wcyIsInJlbmRlclBob3RvIiwib25DbGljayIsImltYWdlU3R5bGUiLCJkaXNwbGF5IiwiYm94U2l6aW5nIiwiYXNwZWN0UmF0aW8iLCJtYXJnaW5Cb3R0b20iLCJjdXJzb3IiLCJoYW5kbGVDbGljayIsImV2ZW50IiwiYWx0IiwidGl0bGUiLCJsb2FkaW5nIiwiZGVjb2RpbmciLCJyZW5kZXJEZWZhdWx0UGhvdG8iLCJvcHRpb25zIiwidW53cmFwcGVkU3R5bGUiLCJyZXN0IiwiY3JlYXRlRWxlbWVudCIsIndyYXBwZWQiLCJ3cmFwcGVyU3R5bGUiLCJGcmFnbWVudCIsImRlZmF1bHRSZW5kZXJSb3dDb250YWluZXIiLCJyb3dDb250YWluZXJQcm9wcyIsImNoaWxkcmVuIiwiUm93Q29udGFpbmVyUmVuZGVyZXIiLCJyb3dJbmRleCIsInJvd3NDb3VudCIsInJlbmRlclJvd0NvbnRhaW5lciIsInJlc3RSb3dDb250YWluZXJQcm9wcyIsImZsZXhEaXJlY3Rpb24iLCJmbGV4V3JhcCIsImFsaWduSXRlbXMiLCJqdXN0aWZ5Q29udGVudCIsIlJvd3NMYXlvdXQiLCJjb21wb25lbnRzUHJvcHMiLCJyb3dzTGF5b3V0Iiwia2V5IiwiY29tcHV0ZVNob3J0ZXN0UGF0aCIsInBhdGhMZW5ndGgiLCJtYXRyaXgiLCJjdXJyZW50UXVldWUiLCJrZXlzIiwiY2xlYXIiLCJhY2N1bXVsYXRlZFdlaWdodCIsInBhdGhzIiwibmV4dFBhdGgiLCJyZWNvbnN0cnVjdFNob3J0ZXN0UGF0aCIsImZpbmRTaG9ydGVzdFBhdGhMZW5ndGhOIiwibWFrZUdldENvbHVtbk5laWdoYm9ycyIsInRhcmdldENvbHVtbldpZHRoIiwidGFyZ2V0Q29sdW1uSGVpZ2h0IiwiY3V0T2ZmSGVpZ2h0IiwiYnVpbGRDb2x1bW5zTW9kZWwiLCJjb2x1bW5zR2FwcyIsImNvbHVtbnNSYXRpb3MiLCJjb2x1bW5zTW9kZWwiLCJ0b3RhbFJhdGlvIiwidG90YWwiLCJjb2x1bW5SYXRpbyIsImNvbHVtbiIsInRvdGFsQWRqdXN0ZWRHYXBzIiwiY29sdW1uV2lkdGgiLCJjb21wdXRlQ29sdW1uc01vZGVsIiwiYXZlcmFnZVJhdGlvIiwiY29sdW1uc01vZGVsMiIsIkFycmF5IiwiZnJvbSIsIl8iLCJjb21wdXRlTGF5b3V0IiwiZmluZEluZGV4IiwiY29sdW1uTW9kZWwiLCJjb21wdXRlQ29sdW1uc0xheW91dCIsImRlZmF1bHRSZW5kZXJDb2x1bW5Db250YWluZXIiLCJjb2x1bW5Db250YWluZXJQcm9wcyIsImNzc0NvbHVtbldpZHRoIiwiY29sdW1uSW5kZXgiLCJjb2x1bW5zQ291bnQiLCJyYXRpbzIiLCJDb2x1bW5Db250YWluZXJSZW5kZXJlciIsInJlbmRlckNvbHVtbkNvbnRhaW5lciIsInJlc3RDb2x1bW5Db250YWluZXJQcm9wcyIsIkNvbHVtbnNMYXlvdXQiLCJjb2x1bW5zTGF5b3V0IiwiY29tcHV0ZU1hc29ucnlMYXlvdXQiLCJjb2x1bW5zQ3VycmVudFRvcFBvc2l0aW9ucyIsIm1vZGVsIiwic2hvcnRlc3RDb2x1bW4iLCJjdXJyZW50U2hvcnRlc3RDb2x1bW4iLCJpdGVtIiwiTWFzb25yeUxheW91dCIsIm1hc29ucnlMYXlvdXQiLCJkZWZhdWx0UmVuZGVyQ29udGFpbmVyIiwiY29udGFpbmVyUHJvcHMiLCJjb250YWluZXJSZWYiLCJyZWYiLCJDb250YWluZXJSZW5kZXJlciIsInJlbmRlckNvbnRhaW5lciIsInJlc3RDb250YWluZXJQcm9wcyIsInVzZUFycmF5IiwiYXJyYXkiLCJ1c2VSZWYiLCJjdXJyZW50IiwiY29udGFpbmVyV2lkdGhSZWR1Y2VyIiwic3RhdGUiLCJuZXdDb250YWluZXJXaWR0aCIsIm5ld1Njcm9sbGJhcldpZHRoIiwic2Nyb2xsYmFyV2lkdGgiLCJyZXNvbHZlQ29udGFpbmVyV2lkdGgiLCJicmVha3BvaW50czIiLCJjbGllbnRXaWR0aCIsInNvcnRlZCIsIngiLCJ0aHJlc2hvbGQiLCJicmVha3BvaW50IiwidXNlQ29udGFpbmVyV2lkdGgiLCJkZWZhdWx0Q29udGFpbmVyV2lkdGgiLCJkaXNwYXRjaCIsInVzZVJlZHVjZXIiLCJvYnNlcnZlclJlZiIsInVzZUNhbGxiYWNrIiwiZGlzY29ubmVjdCIsInVwZGF0ZVdpZHRoIiwid2luZG93IiwiaW5uZXJXaWR0aCIsImRvY3VtZW50IiwiZG9jdW1lbnRFbGVtZW50IiwiUmVzaXplT2JzZXJ2ZXIiLCJvYnNlcnZlIiwiYnJlYWtwb2ludHMiLCJPYmplY3QiLCJmcmVlemUiLCJ1bndyYXAiLCJhcmciLCJ1bndyYXBQYXJhbWV0ZXIiLCJzZWxlY3RSZXNwb25zaXZlVmFsdWUiLCJ2YWx1ZXMiLCJyZXNvbHZlUmVzcG9uc2l2ZVBhcmFtZXRlciIsInBhcmFtZXRlciIsIm1pblZhbHVlIiwicmVzb2x2ZUxheW91dE9wdGlvbnMiLCJ3IiwicmVzb2x2ZUNvbXBvbmVudHNQcm9wcyIsImNvbXBvbmVudHNQcm9wc1Byb3AiLCJzaW5nbGVSb3dNYXhIZWlnaHQiLCJtYXhXaWR0aCIsInJlbmRlckxheW91dCIsImNvbW1vbkxheW91dFByb3BzIiwiUGhvdG9BbGJ1bSIsImluY2x1ZGVzIiwiaXNBcnJheSIsImRlZmF1bHQiLCJ1bnN0YWJsZV9jb21wdXRlQ29sdW1uc0xheW91dCIsInVuc3RhYmxlX2NvbXB1dGVNYXNvbnJ5TGF5b3V0IiwidW5zdGFibGVfY29tcHV0ZVJvd3NMYXlvdXQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-photo-album/dist/index.mjs\n");

/***/ })

};
;